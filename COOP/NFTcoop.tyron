(*
  NFTcoop.tyron: decentralized identifier NFT cooperative project
  Self-Sovereign Identity Protocol.
  Copyright (C) Tyron Pungtas and its affiliates.
  www.ssiprotocol.com

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
*)

scilla_version 0

import IntUtils

library NFT_coop

  (* The DID library *)

  type DIDstatus =
    | Deployed
    | Created
    | Updated
    | Recovered
    | Deactivated

  type Operation =
    | Recovery
    | Update
  
  type Action =
    | Add
    | Remove

  type TransferProtocol =
    | Https
    | Git

  type Endpoint =
    | Uri of String TransferProtocol String   (* type, transfer protocol & uri *)
    | Address of String ByStr20   (* network, address *)

  type Document =
    | VerificationMethod of Action String ByStr33  (* string: key purpose OR service ID *)
    | Service of Action String Endpoint
  
  type Beneficiary =
    | UserDomain of String String
    | BeneficiaryAddr of ByStr20
    
  let didRecovery = Recovery
  let didUpdate = Update
  let update = "update"
  let recovery = "recovery"
  let didsr = "socialrecovery"
  let actionAdd = "add"
  let actionRemove = "remove"
  let psc = "psc"    (* profit-sharing community *)
  
  let one_msg = fun( msg: Message ) =>
    let nil_msg = Nil{ Message } in Cons{ Message } msg nil_msg

  let two_msgs = fun( msg1: Message ) => fun( msg2: Message ) =>
    let msgs_tmp = one_msg msg2 in Cons{ Message } msg1 msgs_tmp

  type Error =
    | CodeWrongStatus
    | CodeNotAdmin
    | CodeWrongCaller
    | CodeWrongSignature
    | CodeUndefinedKey
    | CodeSameKey
    | CodeNotValid
    | CodeInsufficientFunds
 
  let make_error = fun( error: Error ) =>
    let result = match error with
    | CodeWrongStatus            => Int32 -1
    | CodeNotAdmin               => Int32 -2
    | CodeWrongCaller            => Int32 -3
    | CodeWrongSignature         => Int32 -4
    | CodeUndefinedKey           => Int32 -5
    | CodeSameKey                => Int32 -6
    | CodeNotValid               => Int32 -7
    | CodeInsufficientFunds      => Int32 -8
    end in { _exception: "Error"; code: result }
  
  let zero = Uint128 0
  let zeroByStr20 = 0x0000000000000000000000000000000000000000
  let zeroByStr32 = 0x0000000000000000000000000000000000000000000000000000000000000000
  let zeroByStr33 = 0x000000000000000000000000000000000000000000000000000000000000000000
  let zeroByStr64 = 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  let zero_bystr = builtin to_bystr zeroByStr20
  let zeroEndpoint = Address actionRemove zeroByStr20
  
  let option_value = tfun 'A => fun( default: 'A ) => fun( input: Option 'A) =>
    match input with
    | Some v => v
    | None => default
    end
  let option_uint128_value = let f = @option_value Uint128 in f zero
  let option_bystr20_value = let f = @option_value ByStr20 in f zeroByStr20
  let option_bystr33_value = let f = @option_value ByStr33 in f zeroByStr33
  let option_bystr64_value = let f = @option_value ByStr64 in f zeroByStr64
  let option_service = let f = @option_value Endpoint in f zeroEndpoint
  let service_addr = fun( getEndpoint: Option Endpoint ) =>
    let endpoint = option_service getEndpoint
    in match endpoint with
    | Uri tipo transfer uri => zeroByStr20
    | Address network addr => addr end
  
  (* The NFT.coop library *)
  
  type Account =
    | Account of Uint128 Uint128 Uint128 Uint128   (* PRs, merged commits, balance & xPoints *)
    
  type PR =
    | PR of ByStr20 Uint128   (* member & hours *)
  
  let coop = "coop"
  let one = Uint128 1
  let hundred = Uint128 100
  let zeroAccount = Account zero zero zero zero
  let option_account = let f = @option_value Account in f zeroAccount
  
  let account_prs = fun( getAccount: Option Account ) =>
    let account = option_account getAccount
    in match account with
    | Account pull_requests merged balance xps => pull_requests end
  
  let account_merged = fun( getAccount: Option Account ) =>
    let account = option_account getAccount
    in match account with
    | Account prs merged_commits balance xps => merged_commits end
  
  let account_balance = fun( getAccount: Option Account ) =>
    let account = option_account getAccount
    in match account with
    | Account prs merged zil_balance xps => zil_balance end
    
    let account_xps = fun( getAccount: Option Account ) =>
    let account = option_account getAccount
    in match account with
    | Account prs merged balance xpoints => xpoints end
    
  let pr_member = fun( pr: PR ) =>
    match pr with
    | PR member hours => member end
    
  let pr_hours = fun( pr: PR ) =>
    match pr with
    | PR member hours => hours end
    
contract NFT_coop(
  initAdmin: ByStr20 with contract field verification_methods_: Map String ByStr33 end,
  init_tyron: ByStr20 with contract
    field services_: Map String Endpoint,
    field dns: Map String ( Map String ByStr20 ),
    field psc_fee: Map String Uint128 end
  )
  field admin_: ByStr20 with contract field verification_methods_: Map String ByStr33 end = initAdmin
  field did_: String = ""    (* the decentralized identifier *)
  field did_status_: DIDstatus = Deployed
  
  field init_: ByStr20 with contract
    field services_: Map String Endpoint,
    field dns: Map String ( Map String ByStr20 ),
    field psc_fee: Map String Uint128
    end = init_tyron
  
  (* Verification methods
  @key: key purpose
  @value: public key of type "SchnorrSecp256k1VerificationKey2019" *)
  field verification_methods_: Map String ByStr33 = Emp String ByStr33
  
  (* Services
  @key: ID
  @value: the type & URI *)
  field services_: Map String Endpoint = Emp String Endpoint
  field service_addr: Map String ByStr20 = Emp String ByStr20
  
  field document_hash: ByStr = zero_bystr
  
  (* The block number when the DID Create operation occurred *)
  field did_created_: BNum = BNum 0
  
  (* The block number when the last DID CRUD operation occurred *)  
  field ledger_time_: BNum = BNum 0
  
  (* A monotonically increasing number representing the amount of DID CRUD transactions that have taken place *)
  field crud_tx_number_: Uint128 = zero
  
  (* Coop NFTs *)
  
  field members: Map ByStr20 Account = Emp ByStr20 Account

  field contributions: Map ByStr32 PR = Emp ByStr32 PR
  
  field nfts: Map ByStr32 Uint128 = Emp ByStr32 Uint128   (* commit & performance *)
  
  field hourly_wage: Uint128 = hundred   (* hourly wage divided by 100 *)
  
(* The DID backbone *)

procedure ThrowError( err: Error )
  e = make_error err; throw e end

procedure IsOperational()
  did_status <- did_status_;
  match did_status with
  | Deactivated => err = CodeWrongStatus; ThrowError err
  | _ => end end

procedure VerifyAdmin()
  current_admin <- admin_;
  verified = builtin eq current_admin _sender;
  match verified with
  | True =>
  | False => err= CodeNotAdmin; ThrowError err end end

transition UpdateAdmin( addr: ByStr20 with contract field verification_methods_: Map String ByStr33 end )
  IsOperational; VerifyAdmin; admin_ := addr
end

transition UpdateInit(
  addr: ByStr20 with contract
    field services_: Map String Endpoint,
    field dns: Map String ( Map String ByStr20 ),
    field psc_fee: Map String Uint128 end
  )
  IsOperational; VerifyAdmin; init_ := addr end

procedure Payment( id: String )
  current_init <- init_;
  get_fee <-& current_init.psc_fee[id]; fee = option_uint128_value get_fee;
  is_zero = builtin eq fee zero;
  match is_zero with
  | True => err = CodeNotValid; ThrowError err
  | False => accept; msg = let m = { _tag: "AddFunds"; _recipient: current_init; _amount: fee } in one_msg m; send msg end end

(* Verify Schnorr signature - signed data must correspond with a DID Key *)
procedure VerifySignature(
  id: String,
  signedData: ByStr,
  signature: ByStr64
  )
  get_did_key <- verification_methods_[id];
  is_right_signature = let did_key = option_bystr33_value get_did_key in builtin schnorr_verify did_key signedData signature;
  match is_right_signature with
    | True =>
    | False => err = CodeWrongSignature; ThrowError err end end
    
procedure ThrowIfNoKey( optKey: Option ByStr33 )
  match optKey with
  | Some key =>
  | None => err = CodeUndefinedKey; ThrowError err end end

procedure ThrowIfSameKey(
  key: ByStr33,
  sndKey: ByStr33
  )
  is_same_key = builtin eq key sndKey;
  match is_same_key with
  | True => err= CodeSameKey; ThrowError err
  | False => end end

procedure VerifyDIDkeys(
  operation: Operation,
  newRecoveryKey: Option ByStr33,
  newUpdateKey: Option ByStr33
  )
  get_recovery_key <- verification_methods_[recovery]; did_recovery = option_bystr33_value get_recovery_key;
  get_update_key <- verification_methods_[update]; did_update = option_bystr33_value get_update_key;
  match operation with
  | Recovery =>
      ThrowIfNoKey newRecoveryKey; ThrowIfNoKey newUpdateKey;
      recovery_key = option_bystr33_value newRecoveryKey; update_key = option_bystr33_value newUpdateKey;
      ThrowIfSameKey recovery_key update_key; ThrowIfSameKey did_recovery recovery_key; ThrowIfSameKey did_recovery update_key; ThrowIfSameKey did_update recovery_key; ThrowIfSameKey did_update update_key;
      verification_methods_[recovery] := recovery_key; verification_methods_[update] := update_key
  | Update =>
      ThrowIfNoKey newUpdateKey;
      update_key = option_bystr33_value newUpdateKey;
      ThrowIfSameKey did_update update_key; ThrowIfSameKey did_recovery update_key;
      verification_methods_[update] := update_key end end

procedure BuyDomainNameNFT( username: Option String )
  match username with
  | None => err = CodeNotValid; ThrowError err
  | Some name =>
      current_init <- init_;
      get_fee <-& current_init.psc_fee[coop]; fee = option_uint128_value get_fee;
      user_domain = Pair{ String String } name coop;
      accept; msg = let m = { _tag: "BuyDomainNameNFT"; _recipient: current_init; _amount: fee;
        userDomain: user_domain
      } in one_msg m; send msg end end

transition TransferDomainNameNFT(
  username: String,
  newAddr: ByStr20
  )
  current_init <- init_;
  get_fee <-& current_init.psc_fee[coop]; fee = option_uint128_value get_fee;
  user_domain = Pair{ String String } username coop;
  accept; msg = let m = { _tag: "TransferDomainNameNFT"; _recipient: current_init; _amount: fee;
    userDomain: user_domain;
    newAddr: newAddr
  } in one_msg m; send msg end

procedure Timestamp()
  current_block <- &BLOCKNUMBER; ledger_time_ := current_block;
  latest_tx_number <- crud_tx_number_;
  new_tx_number = let incrementor = Uint128 1 in builtin add latest_tx_number incrementor; crud_tx_number_ := new_tx_number end

procedure SaveDocument( document: Document )
  match document with
  | VerificationMethod action purpose key =>
      match action with
      | Add => verification_methods_[purpose] := key
      | Remove => err = CodeNotValid; ThrowError err end
  | Service action id didService =>
      match action with
      | Add => services_[id] := didService
      | Remove => err = CodeNotValid; ThrowError err end end end

transition DIDcreate(
  username: Option String,
  document: Option( List Document ),
  recoveryKey: Option ByStr33,
  updateKey: Option ByStr33,
  signature: Option ByStr64
  )
  did_status <- did_status_;
  match did_status with
  | Deployed =>
    VerifyAdmin; BuyDomainNameNFT username;
    VerifyDIDkeys didRecovery recoveryKey updateKey;
    new_did = let did_prefix = "did:tyron:zil:main:" in let did_suffix = builtin to_string _this_address 
      in builtin concat did_prefix did_suffix; did_ := new_did;
    match document with
    | None => err = CodeNotValid; ThrowError err
    | Some doc => forall doc SaveDocument end;
    new_status = Created; did_status_ := new_status;
    current_block <- &BLOCKNUMBER; did_created_ := current_block; Timestamp
  | _ => err = CodeWrongStatus; ThrowError err end end

procedure UpdateDocument( document: Document )
  match document with
  | VerificationMethod action purpose key =>
      key_exists <- exists verification_methods_[purpose];
      match action with
      | Add =>
          match key_exists with
          | True => err = CodeNotValid; ThrowError err
          | False => verification_methods_[purpose] := key end
      | Remove =>
          match key_exists with
          | True => delete verification_methods_[purpose]
          | False => err = CodeNotValid; ThrowError err end end
  | Service action id didService =>
      service_exists <- exists services_[id];
      match action with
      | Add =>
          match service_exists with
          | True => err = CodeNotValid; ThrowError err
          | False => services_[id] := didService end
      | Remove =>
          match service_exists with
          | True => delete services_[id]
          | False => err = CodeNotValid; ThrowError err end end end end

procedure ValidateDocument(
  operation: Operation,
  document: List Document
  )
  match operation with
  | Recovery => forall document SaveDocument
  | Update => forall document UpdateDocument end end

procedure HashDocument( document: Document )
  doc_hash <- document_hash;
  match document with
  | VerificationMethod action purpose key =>
      match action with
      | Add =>
          hash = let h1 = builtin sha256hash actionAdd 
            in let h2 = builtin sha256hash purpose
            in let h3 = builtin sha256hash key
            in let h1_2 = builtin concat h1 h2
            in builtin concat h1_2 h3;
          doc_hash_ = let hash_ = builtin to_bystr hash in builtin concat doc_hash hash_;
          document_hash := doc_hash_
      | Remove =>
          hash = let h1 = builtin sha256hash actionRemove
            in let h2 = builtin sha256hash purpose
            in builtin concat h1 h2;
          doc_hash_ = let hash_ = builtin to_bystr hash in builtin concat doc_hash hash_;
          document_hash := doc_hash_
      end
  | Service action id endpoint =>
      match action with
      | Add =>
          match endpoint with
          | Uri tipo transfer uri =>
              hash = let h1 = builtin sha256hash actionAdd
              in let h2 = builtin sha256hash id
              in let h3 = builtin sha256hash uri
              in let h1_2 = builtin concat h1 h2
              in builtin concat h1_2 h3;
              doc_hash_ = let hash_ = builtin to_bystr hash in builtin concat doc_hash hash_;
              document_hash := doc_hash_
          | Address network addr =>
              hash = let h1 = builtin sha256hash actionAdd
              in let h2 = builtin sha256hash id
              in let h3 = builtin sha256hash addr
              in let h1_2 = builtin concat h1 h2
              in builtin concat h1_2 h3;
              doc_hash_ = let hash_ = builtin to_bystr hash in builtin concat doc_hash hash_;
              document_hash := doc_hash_
          end
      | Remove =>
          hash = let h1 = builtin sha256hash actionRemove
          in let h2 = builtin sha256hash id
          in builtin concat h1 h2;
          doc_hash_ = let hash_ = builtin to_bystr hash in builtin concat doc_hash hash_;
          document_hash := doc_hash_ end end end

procedure VerifyDocument(
  operation: Operation,
  document: Option( List Document ),
  signature: Option ByStr64
  )
  match document with
  | None => err = CodeNotValid; ThrowError err
  | Some doc =>
      document_hash := zero_bystr;
      forall doc HashDocument;
      doc_hash <- document_hash;
      sig = option_bystr64_value signature;
      id = match operation with
      | Recovery => recovery
      | Update => update
      end;
      VerifySignature id doc_hash sig;
      ValidateDocument operation doc end end

transition DIDrecover(
  username: Option String,
  document: Option( List Document ),
  recoveryKey: Option ByStr33,
  updateKey: Option ByStr33,
  signature: Option ByStr64
  )
  IsOperational; VerifyAdmin; VerifyDIDkeys didRecovery recoveryKey updateKey;
  VerifyDocument didRecovery document signature;
  new_status = Recovered; did_status_ := new_status; Timestamp end

transition DIDupdate(
  username: Option String,
  document: Option( List Document ),
  recoveryKey: Option ByStr33,
  updateKey: Option ByStr33,
  signature: Option ByStr64
  )
  IsOperational; VerifyAdmin; VerifyDIDkeys didUpdate recoveryKey updateKey;
  VerifyDocument didUpdate document signature;
  new_status = Updated; did_status_ := new_status; Timestamp end

transition DIDdeactivate(
  username: Option String,
  document: Option( List Document ),
  recoveryKey: Option ByStr33,
  updateKey: Option ByStr33,
  signature: Option ByStr64
  ) 
  IsOperational; VerifyAdmin;
  VerifyDocument didRecovery document signature;
  deactivated_methods = Emp String ByStr33; verification_methods_ := deactivated_methods;
  deactivated_services = Emp String Endpoint; services_ := deactivated_services;
  new_status = Deactivated; did_status_ := new_status; Timestamp end

(* Receive $ZIL native funds *)
transition AddFunds()
  IsOperational; accept end

(* Send $ZIL to any recipient that implements the tag, e.g. "AddFunds", "", etc. *)
transition SendFunds(
  tag: String,
  beneficiary: Beneficiary
  )
  IsOperational; VerifyAdmin;
  match beneficiary with
  | UserDomain username domain =>
      current_init <- init_;
      get_addr <-& current_init.dns[domain][username]; addr = option_bystr20_value get_addr;
      accept; msg = let m = { _tag: tag; _recipient: addr; _amount: _amount } in one_msg m; send msg
  | BeneficiaryAddr addr =>
      accept; msg = let m = { _tag: tag; _recipient: addr; _amount: _amount } in one_msg m; send msg end end

procedure FetchServiceAddr( id: String )
  current_init <- init_; get_service <-& current_init.services_[id]; addr = service_addr get_service; service_addr[id] := addr end

transition Transfer(
  addrName: String,
  beneficiary: Beneficiary,
  amount: Uint128
  ) 
  IsOperational; VerifyAdmin;
  FetchServiceAddr addrName; get_token_addr <- service_addr[addrName]; token_addr = option_bystr20_value get_token_addr;
  match beneficiary with
  | UserDomain username domain =>
      current_init <- init_;
      get_addr <-& current_init.dns[domain][username]; addr = option_bystr20_value get_addr;
      msg = let m = { _tag: "Transfer"; _recipient: token_addr; _amount: zero;
        to: addr;
        amount: amount
      } in one_msg m ; send msg
  | BeneficiaryAddr addr =>
      msg = let m = { _tag: "Transfer"; _recipient: token_addr; _amount: zero;
        to: addr;
        amount: amount
      } in one_msg m ; send msg end end

transition RecipientAcceptTransfer(
  sender: ByStr20,
  recipient: ByStr20,
  amount: Uint128
  )
  IsOperational end

transition RecipientAcceptTransferFrom(
  initiator: ByStr20,
  sender: ByStr20,
  recipient: ByStr20,
  amount: Uint128
  )
  IsOperational end

transition TransferSuccessCallBack(
  sender: ByStr20, 
  recipient: ByStr20,
  amount : Uint128
  )
  IsOperational end

transition TransferFromSuccessCallBack(
  initiator: ByStr20,
  sender: ByStr20,
  recipient: ByStr20,
  amount: Uint128
  )
  IsOperational end

(* The NFT.coop backbone *)

transition UpdateHourlyWage( amount: Uint128 )
  VerifyAdmin; hourly_wage := amount end

transition AddMember( addr: ByStr20 )
  VerifyAdmin;
  new_account = Account zero zero zero zero;
  members[addr] := new_account end
  
transition NFTTransfer(
  beneficiary: Beneficiary,
  amount: Uint128
  ) 
  IsOperational; get_account <- members[_sender];
  match get_account with
  | None => err = CodeWrongCaller; ThrowError err
  | Some account =>
      match beneficiary with
      | UserDomain username domain =>
          current_init <- init_; get_addr <-& current_init.dns[domain][username]; addr = option_bystr20_value get_addr;
          members[addr] := account; delete members[_sender]
      | BeneficiaryAddr addr =>
          members[addr] := account; delete members[_sender] end end end

transition AddWork(
  transferProtocol: TransferProtocol,
  uri: String,   
  amount: Uint128   (* hours *)
  )
  IsOperational; get_account <- members[_sender];
  match get_account with
  | None => err = CodeWrongCaller; ThrowError err
  | Some account =>
      prs = account_prs get_account; merged = account_merged get_account; balance = account_balance get_account; xpoints = account_xps get_account;
      current_block <- &BLOCKNUMBER;
      commit = let h1 = builtin sha256hash _sender
      in let h2 = builtin sha256hash uri
      in let h3 = builtin sha256hash current_block
      in let h1_2 = builtin concat h1 h2
      in let h1__3 = builtin concat h1_2 h3
      in builtin sha256hash h1__3;
      new_endpoint = Uri coop transferProtocol uri; id = builtin to_string commit; services_[id] := new_endpoint;
      new_pr = PR _sender amount; contributions[commit] := new_pr;
      updated_account = let updated_prs = builtin add prs one in Account updated_prs merged balance xpoints; members[_sender] := updated_account end end

transition AssessPerformance(
  commit: ByStr32,
  amount: Uint128   (* performance: 20(%) = 1 star, 100(%) = 5 stars *)
  )
  IsOperational; VerifyAdmin;
  get_pr <- contributions[commit];
  match get_pr with
  | None => err = CodeNotValid; ThrowError err
  | Some pr =>
      member = pr_member pr; hours = pr_hours pr;
      get_account <- members[member]; prs = account_prs get_account; merged = account_merged get_account; balance = account_balance get_account; xpoints = account_xps get_account;
      nfts[commit] := amount;
      current_hourly_wage <- hourly_wage;
      updated_account = let updated_merged = builtin add merged one   (* transfer NFT value to contributor *)
        in let earnings_percent = builtin mul hours current_hourly_wage
        in let earnings = builtin mul earnings_percent amount
        in let updated_balance = builtin add balance earnings
        in let updated_xps = builtin add xpoints amount
        in Account prs updated_merged updated_balance updated_xps; members[member] := updated_account;
      id = builtin to_string commit; delete services_[id] end end

transition RemoveService( commit: ByStr32 )
  IsOperational; VerifyAdmin;
  get_pr <- contributions[commit];
  match get_pr with
  | None => err = CodeNotValid; ThrowError err
  | Some pr => delete contributions[commit]; id = builtin to_string commit; delete services_[id] end end
  
transition WithdrawEarnings( amount: Uint128 )
  IsOperational; get_account <- members[_sender];
  match get_account with
  | None => err = CodeWrongCaller; ThrowError err
  | Some account =>
      prs = account_prs get_account; merged = account_merged get_account; balance = account_balance get_account; xpoints = account_xps get_account;
      sufficient_funds = uint128_ge balance amount;
      match sufficient_funds with
      | True =>
          updated_account = let new_balance = builtin sub balance amount in Account prs merged new_balance xpoints; members[_sender] := updated_account;
          msg = let m = { _tag: "AddFunds"; _recipient: _sender; _amount: amount } in one_msg m; send msg
      | False => err = CodeInsufficientFunds; ThrowError err end end end