(*
  PST ZRC: profit-sharing token Zilliqa reference contract - Proxy smart contract.
  Tyron Self-Sovereign Identity Protocol.
  Copyright (C) Tyron Pungtas and its affiliates.

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
*)

scilla_version 0

import BoolUtils IntUtils PairUtils ListUtils

library PSTproxy

  let one_msg = fun( msg: Message ) =>
    let nil_msg = Nil{ Message } in Cons{ Message } msg nil_msg

  type Error =
    | CodeWrongCaller

  let make_error = fun( error: Error ) =>
    let result = match error with
    | CodeWrongCaller            => Int32 -1
    end in { _exception: "Error"; code: result }

  let zero = Uint128 0
  let zeroBalance = Pair{ Uint128 Uint128 } zero zero
  
  let option_value = tfun 'A => fun( default: 'A ) => fun( input: Option 'A ) =>
    match input with
    | Some v => v
    | None => default
    end
  
  let option_uint128_value = let f = @option_value Uint128 in f zero
  
  let option_balance_pair = let f = @option_value ( Pair Uint128 Uint128 ) in f zeroBalance
    
  let option_balance_value = fun( getBal: Option( Pair Uint128 Uint128 ) ) =>
    let balance_pair = option_balance_pair getBal
    in let fst_element = @fst Uint128 Uint128
    in fst_element balance_pair
    
  let option_balance_share = fun( getBal: Option( Pair Uint128 Uint128 ) ) =>
    let balance_pair = option_balance_pair getBal
    in let snd_element = @snd Uint128 Uint128
    in snd_element balance_pair
  
  let compare_member = fun( addr: ByStr20 ) => fun( member: ByStr20 ) => builtin eq addr member
  
  let share_profits: forall 'A. List ByStr20 -> Map ByStr20 ( Pair Uint128 Uint128 ) -> Uint128 -> Map ByStr20 ( Pair Uint128 Uint128 ) 
    = tfun 'A => fun( l: List ByStr20 ) => fun( prevBalances: Map ByStr20 ( Pair Uint128 Uint128 ) ) => fun( p: Uint128 ) =>
    let list_foldl = @list_foldl ByStr20 Map ByStr20 ( Pair Uint128 Uint128 )
    in let iter = fun( balances: Map ByStr20 ( Pair Uint128 Uint128 ) ) => fun( agent: ByStr20 ) =>
      let new_balance =
        let get_bal = builtin get balances agent 
        in let s = option_balance_share get_bal
        in let profit = builtin mul p s
        in let balance = option_balance_value get_bal
        in builtin add balance profit
      in let new_s = zero
      in let updated_balance = Pair{ Uint128 Uint128 } new_balance new_s
      in builtin put balances agent updated_balance
    in list_foldl iter prevBalances l

contract PSTproxy(
  initAdmin: ByStr20,
  name: String,
  symbol: String,
  decimals: Uint32,
  initSupply: Uint128,
  initImplementation: ByStr20,
  f: Uint128,
  t: Uint128
  (* to-do create and update f & t fields *)
  )
  with
    let string_is_not_empty = fun( s : String ) =>
      let zero = Uint32 0 in
      let s_length = builtin strlen s in
      let s_empty = builtin eq s_length zero in
      negb s_empty
    in let name_ok = string_is_not_empty name
    in let symbol_ok = string_is_not_empty symbol
    in let name_symbol_ok = andb name_ok symbol_ok
    in let decimals_ok =
      let six = Uint32 6
      in let eighteen = Uint32 18
      in let decimals_at_least_6 = uint32_le six decimals
      in let decimals_no_more_than_18 = uint32_le decimals eighteen
      in andb decimals_at_least_6 decimals_no_more_than_18
      in andb name_symbol_ok decimals_ok
  =>
  field admin: ByStr20 = initAdmin
  field implementation: ByStr20 = initImplementation
  field balances: Map ByStr20 ( Pair Uint128 Uint128 ) = let emp_map = Emp ByStr20 ( Pair Uint128 Uint128 ) in let init = Pair{ Uint128 Uint128 } initSupply f in builtin put emp_map initAdmin init
  field total_supply: Uint128 = initSupply
  field allowances: Map ByStr20 ( Map ByStr20 Uint128 ) = Emp ByStr20 ( Map ByStr20 Uint128 )
  field agents: List ByStr20 = let nil = Nil{ ByStr20 } in Cons{ ByStr20 } initAdmin nil
    
procedure ThrowError(
  err: Error
  )
  e = make_error err; throw e
end

procedure VerifyCaller(
  addr: ByStr20
  )
  verified = builtin eq addr _sender;
  match verified with
  | True =>
  | False => err= CodeWrongCaller; ThrowError err
  end
end

(* ZRC-5 add native funds ($ZIL) to the contract's _balance *)
transition AddFunds()
  accept
end

transition UpgradeImplementation(
  newImplementation: ByStr20
  )
  current_admin <- admin; VerifyCaller current_admin;
  implementation := newImplementation;
  e = {
    _eventname: "ImplementationUpgraded";
    newImplementation: newImplementation
  }; event e
end

transition UpdateProxyAdmin(
  newAdmin: ByStr20
  )
  current_admin <- admin; VerifyCaller current_admin;
  admin := newAdmin;
  e = {
    _eventname: "AdminUpdated";
    to: newAdmin
  }; event e
end

transition UpdateImplementationAdmin(
  newAdmin: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "UpdateImplementationAdmin";
    _recipient: current_impl;
    _amount: zero;
    newAdmin: newAdmin;
    initiator: _sender
  } in one_msg m; send msg
end

transition UpdatePauser(
  newPauser: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "UpdatePauser";
    _recipient: current_impl;
    _amount: zero;
    newPauser: newPauser;
    initiator: _sender
  } in one_msg m; send msg
end

transition Pause()
  current_impl <- implementation;
  msg = let m = {
    _tag: "Pause";
    _recipient: current_impl;
    _amount: zero;
    initiator: _sender
  } in one_msg m; send msg
end

transition Unpause()
  current_impl <- implementation;
  msg = let m = {
    _tag: "Unpause";
    _recipient: current_impl;
    _amount: zero;
    initiator: _sender
  } in one_msg m; send msg
end

transition UpdateBlacklister(
  newBlacklister: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "UpdateBlacklister";
    _recipient: current_impl;
    _amount: zero;
    newBlacklister: newBlacklister;
    initiator: _sender
  } in one_msg m; send msg
end

transition Blacklist(
  addr: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "Blacklist";
    _recipient: current_impl;
    _amount: zero;
    addr: addr;
    initiator: _sender
  } in one_msg m; send msg
end

transition Unblacklist(
  addr: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "Unblacklist";
    _recipient: current_impl;
    _amount: zero;
    addr: addr;
    initiator: _sender
  } in one_msg m; send msg
end

transition UpdateMasterMinter(
  newMasterMinter: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "UpdateMasterMinter";
    _recipient: current_impl;
    _amount: zero;
    initiator: _sender;
    newMasterMinter: newMasterMinter
  } in one_msg m; send msg
end

transition IncreaseMinterAllowance(
  minter: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "IncreaseMinterAllowance";
    _recipient: current_impl;
    _amount: zero;
    minter: minter;
    amount: amount;
    initiator: _sender
  } in one_msg m; send msg
end

transition DecreaseMinterAllowance(
  minter: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "DecreaseMinterAllowance";
    _recipient: current_impl;
    _amount: zero;
    minter: minter;
    amount: amount;
    initiator: _sender
  } in one_msg m; send msg
end

transition Mint(
  to: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  current_supply <- total_supply;
  get_to_bal <- balances[to]; to_bal = option_balance_value get_to_bal;
  msg = let m = {
    _tag: "Mint";
    _recipient: current_impl;
    _amount: zero;
    to: to;
    amount: amount;
    toBal: to_bal;
    currentSupply: current_supply;
    initiator: _sender
  } in one_msg m; send msg
end

procedure RegisterBalance(
  addr: ByStr20,
  bal: Uint128
  )
  not_enough = let n = builtin sub t f in builtin lt bal n;
  list_mem = @list_mem ByStr20;
  agents_list <- agents;
  is_member = list_mem compare_member addr agents_list;
  match not_enough with
  | True => 
      balance = Pair{ Uint128 Uint128 } bal zero;
      balances[addr] := balance;
      match is_member with
      | True =>
          list_filter = @list_filter ByStr20;
          remove_member = fun( member: ByStr20 ) =>
            let is_addr = builtin eq addr member
            in negb is_addr;
          agents_updated = list_filter remove_member agents_list;
          agents := agents_updated
      | False =>
      end
  | False =>
      balance =
        let s = 
          let product = builtin mul bal f
          in builtin div product t
        in Pair{ Uint128 Uint128 } bal s;
      balances[addr] := balance;
      match is_member with
      | True =>
      | False =>
          agents_updated = Cons{ ByStr20 } addr agents_list;
          agents := agents_updated
      end
  end
end

transition MintCallBack(
  to: ByStr20,
  newToBal: Uint128,
  newSupply: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  RegisterBalance to newToBal;
  total_supply := newSupply
end

transition Burn(
  amount: Uint128
  )
  current_impl <- implementation;
  current_supply <- total_supply;
  get_burn_bal <- balances[_sender]; burn_bal = option_balance_value get_burn_bal;
  msg = let m = {
    _tag: "Burn";
    _recipient: current_impl;
    _amount: zero;
    amount: amount;
    initiator: _sender;
    initiatorBal: burn_bal;
    currentSupply: current_supply
  } in one_msg m; send msg
end

transition BurnCallBack(
  initiator: ByStr20,
  newMinterBalance: Uint128,
  newSupply: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  RegisterBalance initiator newMinterBalance;
  total_supply := newSupply
end

transition LawEnforcementWipingBurn(
  addr: ByStr20
  )
  current_impl <- implementation;
  current_supply <- total_supply;
  get_bal <- balances[addr]; bal = option_balance_value get_bal;
  msg = let m = {
    _tag: "LawEnforcementWipingBurn";
    _recipient: current_impl;
    _amount: zero;
    addr: addr;
    addrBal: bal;
    currentSupply: current_supply;
    initiator: _sender
  } in one_msg m; send msg
end

transition LawEnforcementWipingBurnCallBack(
  addr: ByStr20,
  newSupply: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  balances[addr] := zeroBalance;
  total_supply := newSupply
end

transition IncreaseAllowance(
  spender: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  get_allowance <- allowances[_sender][spender]; allowance = option_uint128_value get_allowance;
  msg = let m = {
    _tag: "IncreaseAllowance";
    _recipient: current_impl;
    _amount: zero;
    spender: spender;
    amount: amount;
    currentAllowance: allowance;
    initiator: _sender
  } in one_msg m; send msg
end

transition DecreaseAllowance(
  spender: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  get_allowance <- allowances[_sender][spender]; allowance = option_uint128_value get_allowance;
  msg = let m = {
    _tag: "DecreaseAllowance";
    _recipient: current_impl;
    _amount: zero;
    spender: spender;
    amount: amount;
    initiator: _sender;
    currentAllowance: allowance
  } in one_msg m; send msg
end

transition AllowanceCallBack(
  initiator: ByStr20,
  spender: ByStr20,
  newAllowance: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  allowances[initiator][spender] := newAllowance
end

transition Transfer(
  to: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  get_from_bal <- balances[_sender]; from_bal = option_balance_value get_from_bal;
  get_to_bal <- balances[to]; to_bal = option_balance_value get_to_bal;
  msg = let m = {
    _tag: "Transfer";
    _recipient: current_impl;
    _amount: zero;
    to: to;
    amount: amount;
    initiator: _sender;
    fromBal: from_bal;
    toBal: to_bal
  } in one_msg m; send msg
end

transition TransferCallBack(
  from: ByStr20,
  newFromBal: Uint128,
  to: ByStr20,
  newToBal: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  RegisterBalance from newFromBal;
  RegisterBalance to newToBal
end

transition TransferFrom(
  from: ByStr20, 
  to: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  get_to_bal <- balances[to];
  to_bal = option_balance_value get_to_bal;
  get_from_bal <- balances[from]; from_bal = option_balance_value get_from_bal;
  get_allowance <- allowances[from][_sender]; allowance = option_uint128_value get_allowance;
  msg = let m = {
    _tag: "TransferFrom";
    _recipient: current_impl;
    _amount: zero;
    from: from;
    to: to;
    amount: amount;
    initiator: _sender;
    fromBal: from_bal;
    spenderAllowance: allowance;
    toBal: to_bal
  } in one_msg m; send msg
end

transition TransferFromCallBack(
  from: ByStr20,
  to: ByStr20,
  newFromBal: Uint128,
  newToBal: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  RegisterBalance from newFromBal;
  RegisterBalance to newToBal
end

transition SwapZILForPST(
  minPstAmount: Uint128
  )
  current_impl <- implementation;
  balance <- _balance;
  msg = let m = {
    _tag: "SwapZILforPST";
    _recipient: current_impl;
    _amount: balance;
    minPstAmount: minPstAmount
  } in one_msg m; send msg
end

(* to-do perhaps merge SwapZILForPST with ProfitShare *)

transition ProfitShare()
  current_admin <- admin; VerifyCaller current_admin;
  current_impl <- implementation;
  get_bal <- balances[current_impl]; bal = option_balance_value get_bal;
  p = builtin div bal f;
  agents_list <- agents;
  current_balances <- balances;
  new_balances =
    let share_profits = @share_profits ByStr20
    in share_profits agents_list current_balances p;
  balances := new_balances
end
