(*
  PST ZRC: profit-sharing token Zilliqa reference contract - Proxy smart contract.
  Tyron Self-Sovereign Identity Protocol.
  Copyright (C) Tyron Pungtas and its affiliates.

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
*)

scilla_version 0

import BoolUtils IntUtils PairUtils ListUtils

library PSTproxy

  let one_msg = fun( msg: Message ) =>
    let nil_msg = Nil{ Message } in Cons{ Message } msg nil_msg

  type Error =
    | CodeWrongCaller
    | CodeNotValid

  let make_error = fun( error: Error ) =>
    let result = match error with
    | CodeWrongCaller            => Int32 -1
    | CodeNotValid               => Int32 -2
    end in { _exception: "Error"; code: result }

  let zero = Uint128 0
  let zeroBalance = Pair{ Uint128 Uint128 } zero zero
  
  let option_value = tfun 'A => fun( default: 'A ) => fun( input: Option 'A ) =>
    match input with
    | Some v => v
    | None => default
    end
  
  let option_uint128_value = let f = @option_value Uint128 in f zero
  
  let option_balance_pair = let f = @option_value ( Pair Uint128 Uint128 ) in f zeroBalance
    
  let option_balance_value = fun( getBal: Option( Pair Uint128 Uint128 ) ) =>
    let balance_pair = option_balance_pair getBal
    in let fst_element = @fst Uint128 Uint128
    in fst_element balance_pair
    
  let option_balance_share = fun( getBal: Option( Pair Uint128 Uint128 ) ) =>
    let balance_pair = option_balance_pair getBal
    in let snd_element = @snd Uint128 Uint128
    in snd_element balance_pair
  
  let compare_member = fun( addr: ByStr20 ) => fun( member: ByStr20 ) => builtin eq addr member

contract PSTproxy(
  initAdmin: ByStr20,
  initDao: ByStr20,
  name: String,
  symbol: String,
  decimals: Uint32,
  initSupply: Uint128,
  f: Uint128
  (* to-do create and update f & t fields *)
  )
  with
    let string_is_not_empty = fun( s : String ) =>
      let zero = Uint32 0 in
      let s_length = builtin strlen s in
      let s_empty = builtin eq s_length zero in
      negb s_empty
    in let name_ok = string_is_not_empty name
    in let symbol_ok = string_is_not_empty symbol
    in let name_symbol_ok = andb name_ok symbol_ok
    in let decimals_ok =
      let six = Uint32 6
      in let eighteen = Uint32 18
      in let decimals_at_least_6 = uint32_le six decimals
      in let decimals_no_more_than_18 = uint32_le decimals eighteen
      in andb decimals_at_least_6 decimals_no_more_than_18
      in andb name_symbol_ok decimals_ok
  =>
  field admin: ByStr20 = initAdmin
  field dao: ByStr20 = initDao
  field implementation: ByStr20 = initAdmin
  field balances: Map ByStr20 ( Pair Uint128 Uint128 ) = let emp_map = Emp ByStr20 ( Pair Uint128 Uint128 ) in let init = Pair{ Uint128 Uint128 } initSupply f in builtin put emp_map initAdmin init
  field total_supply: Uint128 = initSupply
  field allowances: Map ByStr20 ( Map ByStr20 Uint128 ) = Emp ByStr20 ( Map ByStr20 Uint128 )
  field agents: List ByStr20 = let nil = Nil{ ByStr20 } in Cons{ ByStr20 } initAdmin nil
  field p: Uint128 = zero
  field subtotal: Uint128 = zero
  
procedure ThrowError(
  err: Error
  )
  e = make_error err; throw e
end

procedure VerifyCaller(
  addr: ByStr20
  )
  verified = builtin eq addr _sender;
  match verified with
  | True =>
  | False => err= CodeWrongCaller; ThrowError err
  end
end

(* ZRC-5 add native funds ($ZIL) to the contract's _balance *)
transition AddFunds()
  accept
end

transition UpgradeImplementation(
  newImplementation: ByStr20
  )
  current_admin <- admin; VerifyCaller current_admin;
  implementation := newImplementation;
  e = {
    _eventname: "ImplementationUpgraded";
    newImplementation: newImplementation
  }; event e
end

transition UpdateProxyAdmin(
  newAdmin: ByStr20
  )
  current_admin <- admin; VerifyCaller current_admin;
  admin := newAdmin;
  e = {
    _eventname: "AdminAddressUpdated";
    newAdmin: newAdmin
  }; event e
end

transition UpdateDaoAddr(
  newAddr: ByStr20
  )
  current_admin <- admin; VerifyCaller current_admin;
  dao := newAddr;
  e = {
    _eventname: "DaoAddressUpdated";
    newAddress: newAddr
  }; event e
end

transition UpdateImplementationAdmin(
  newAdmin: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "UpdateImplementationAdmin";
    _recipient: current_impl;
    _amount: zero;
    newAdmin: newAdmin
  } in one_msg m; send msg
end

transition UpdatePauser(
  newPauser: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "UpdatePauser";
    _recipient: current_impl;
    _amount: zero;
    newPauser: newPauser
  } in one_msg m; send msg
end

transition Pause()
  current_impl <- implementation;
  msg = let m = {
    _tag: "Pause";
    _recipient: current_impl;
    _amount: zero
  } in one_msg m; send msg
end

transition Unpause()
  current_impl <- implementation;
  msg = let m = {
    _tag: "Unpause";
    _recipient: current_impl;
    _amount: zero
  } in one_msg m; send msg
end

transition UpdateBlacklister(
  newBlacklister: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "UpdateBlacklister";
    _recipient: current_impl;
    _amount: zero;
    newBlacklister: newBlacklister
  } in one_msg m; send msg
end

transition Blacklist(
  addr: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "Blacklist";
    _recipient: current_impl;
    _amount: zero;
    addr: addr
  } in one_msg m; send msg
end

transition Unblacklist(
  addr: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "Unblacklist";
    _recipient: current_impl;
    _amount: zero;
    addr: addr
  } in one_msg m; send msg
end

transition UpdateMasterMinter(
  newMasterMinter: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "UpdateMasterMinter";
    _recipient: current_impl;
    _amount: zero;
    newMasterMinter: newMasterMinter
  } in one_msg m; send msg
end

transition IncreaseMinterAllowance(
  minter: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "IncreaseMinterAllowance";
    _recipient: current_impl;
    _amount: zero;
    minter: minter;
    amount: amount
  } in one_msg m; send msg
end

transition DecreaseMinterAllowance(
  minter: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "DecreaseMinterAllowance";
    _recipient: current_impl;
    _amount: zero;
    minter: minter;
    amount: amount
  } in one_msg m; send msg
end

transition Mint(
  beneficiary: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  current_supply <- total_supply;
  get_beneficiary_bal <- balances[beneficiary]; beneficiary_bal = option_balance_value get_beneficiary_bal;
  msg = let m = {
    _tag: "Mint";
    _recipient: current_impl;
    _amount: zero;
    beneficiary: beneficiary;
    amount: amount;
    beneficiaryBal: beneficiary_bal;
    currentSupply: current_supply
  } in one_msg m; send msg
end

procedure RegisterBalance(
  addr: ByStr20,
  bal: Uint128
  )
  t <- total_supply;
  not_enough = let n = builtin div t f in builtin lt bal n;
  list_mem = @list_mem ByStr20;
  agents_list <- agents;
  is_member = list_mem compare_member addr agents_list;
  match not_enough with
  | True => 
      balance = Pair{ Uint128 Uint128 } bal zero;
      balances[addr] := balance;
      match is_member with
      | True =>
          list_filter = @list_filter ByStr20;
          remove_member = fun( member: ByStr20 ) =>
            let is_addr = builtin eq addr member
            in negb is_addr;
          agents_updated = list_filter remove_member agents_list;
          agents := agents_updated
      | False =>
      end
  | False =>
      balance =
        let s = let ebal = builtin mul bal f in builtin div ebal t
        in Pair{ Uint128 Uint128 } bal s;
      balances[addr] := balance;
      match is_member with
      | True =>
      | False =>
          agents_updated = Cons{ ByStr20 } addr agents_list;
          agents := agents_updated
      end
  end
end

transition MintCallBack(
  beneficiary: ByStr20,
  newBeneficiaryBal: Uint128,
  newSupply: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  RegisterBalance beneficiary newBeneficiaryBal;
  total_supply := newSupply
end

transition Burn(
  amount: Uint128
  )
  current_impl <- implementation;
  current_supply <- total_supply;
  get_minter_bal <- balances[_sender]; minter_bal = option_balance_value get_minter_bal;
  msg = let m = {
    _tag: "Burn";
    _recipient: current_impl;
    _amount: zero;
    amount: amount;
    minterBal: minter_bal;
    currentSupply: current_supply
  } in one_msg m; send msg
end

transition BurnCallBack(
  newMinterBalance: Uint128,
  newSupply: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  RegisterBalance _origin newMinterBalance;
  total_supply := newSupply
end

transition LawEnforcementWipingBurn(
  addr: ByStr20
  )
  current_impl <- implementation;
  current_supply <- total_supply;
  get_bal <- balances[addr]; bal = option_balance_value get_bal;
  msg = let m = {
    _tag: "LawEnforcementWipingBurn";
    _recipient: current_impl;
    _amount: zero;
    addr: addr;
    addrBal: bal;
    currentSupply: current_supply
  } in one_msg m; send msg
end

transition LawEnforcementWipingBurnCallBack(
  addr: ByStr20,
  newSupply: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  delete balances[addr];
  total_supply := newSupply
end

transition IncreaseAllowance(
  spender: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  get_allowance <- allowances[_sender][spender]; allowance = option_uint128_value get_allowance;
  msg = let m = {
    _tag: "IncreaseAllowance";
    _recipient: current_impl;
    _amount: zero;
    originator: _sender;
    spender: spender;
    amount: amount;
    currentAllowance: allowance
  } in one_msg m; send msg
end

transition DecreaseAllowance(
  spender: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  get_allowance <- allowances[_sender][spender]; allowance = option_uint128_value get_allowance;
  msg = let m = {
    _tag: "DecreaseAllowance";
    _recipient: current_impl;
    _amount: zero;
    originator: _sender;
    spender: spender;
    amount: amount;
    currentAllowance: allowance
  } in one_msg m; send msg
end

transition AllowanceCallBack(
  originator: ByStr20,
  spender: ByStr20,
  newAllowance: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  allowances[originator][spender] := newAllowance
end

transition Transfer(
  to: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  get_originator_bal <- balances[_sender]; originator_bal = option_balance_value get_originator_bal;
  get_beneficiary_bal <- balances[to]; beneficiary_bal = option_balance_value get_beneficiary_bal;
  msg = let m = {
    _tag: "Transfer";
    _recipient: current_impl;
    _amount: zero;
    originator: _sender;
    beneficiary: to;
    amount: amount;
    originatorBal: originator_bal;
    beneficiaryBal: beneficiary_bal
  } in one_msg m; send msg
end

transition TransferCallBack(
  originator: ByStr20,
  beneficiary: ByStr20,
  newOriginatorBal: Uint128,
  newBeneficiaryBal: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  RegisterBalance originator newOriginatorBal;
  RegisterBalance beneficiary newBeneficiaryBal
end

transition TransferFrom(
  from: ByStr20, 
  to: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  get_beneficiary_bal <- balances[to]; beneficiary_bal = option_balance_value get_beneficiary_bal;
  get_originator_bal <- balances[from]; originator_bal = option_balance_value get_originator_bal;
  get_allowance <- allowances[from][_sender]; allowance = option_uint128_value get_allowance;
  msg = let m = {
    _tag: "TransferFrom";
    _recipient: current_impl;
    _amount: zero;
    originator: from;
    spender: _sender;
    beneficiary: to;
    amount: amount;
    originatorBal: originator_bal;
    spenderAllowance: allowance;
    beneficiaryBal: beneficiary_bal
  } in one_msg m; send msg
end

transition TransferFromCallBack(
  originator: ByStr20,
  beneficiary: ByStr20,
  newOriginatorBal: Uint128,
  newBeneficiaryBal: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  RegisterBalance originator newOriginatorBal;
  RegisterBalance beneficiary newBeneficiaryBal
end

transition SwapZILForPSTAndShare(
  beneficiary: Option( List ByStr20 ),
  minPstAmount: Uint128,
  blockDeadline: Uint128
  )
  current_impl <- implementation; accept;
  msg = let m = {
    _tag: "SwapZILForPSTAndShare";
    _recipient: current_impl;
    _amount: _amount;
    minPstAmount: minPstAmount;
    originator: _sender;
    beneficiary: beneficiary;
    blockDeadline: blockDeadline
  } in one_msg m; send msg
end

procedure UpdateP(
  bal: Uint128
  )
  this_p = builtin div bal f;
  p := this_p
end

procedure DistributeProfit(
  beneficiary: ByStr20
  )
  get_bal <- balances[beneficiary]; bal = option_balance_value get_bal; s = option_balance_share get_bal;
  profit <- p;
  after_profit_balance = let profit_share = builtin mul profit s in builtin add bal profit_share;
  RegisterBalance beneficiary after_profit_balance
end

procedure UpdateSubtotal(
  beneficiary: ByStr20
  )
  get_bal <- balances[beneficiary]; bal = option_balance_value get_bal;
  current_subtotal <- subtotal;
  update_subtotal = builtin add current_subtotal bal;
  subtotal := update_subtotal
end

procedure DistributePST(
  beneficiary: ByStr20
  )
  get_bal <- balances[beneficiary]; bal = option_balance_value get_bal;
  this_subtotal <- subtotal;
  this_p <- p;
  new_balance = let ebal = builtin mul bal f in let s = builtin div ebal this_subtotal in let share = builtin mul this_p s in builtin add bal share;
  RegisterBalance beneficiary new_balance
end

transition ProfitShareCallBack(
  originator: ByStr20,
  beneficiary: Option( List ByStr20 )
  )
  current_impl <- implementation; VerifyCaller current_impl;
  get_bal <- balances[originator]; bal = option_balance_value get_bal;
  UpdateP bal;
  current_dao <- dao;
  is_dao = builtin eq originator current_dao;
  match is_dao with
  | True =>
      agents_list <- agents;
      forall agents_list DistributeProfit;
      get_after_bal <- balances[current_dao]; after_bal = option_balance_value get_after_bal;
      burn = builtin sub after_bal bal;
      delete balances[current_dao];
      current_supply <- total_supply;
      new_supply = builtin sub current_supply burn;
      total_supply := new_supply
  | False =>
      match beneficiary with
      | Some list =>
          subtotal := zero;
          forall list UpdateSubtotal;
          forall list DistributePST
      | None => err = CodeNotValid; ThrowError err
      end
  end
end