(*
  PST ZRC: profit-sharing token Zilliqa reference contract - Proxy smart contract.
  Tyron Self-Sovereign Identity Protocol.
  Copyright (C) Tyron Pungtas and its affiliates.

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
*)

scilla_version 0

import BoolUtils IntUtils PairUtils ListUtils

library PSTproxy

  let one_msg = fun( msg: Message ) =>
    let nil_msg = Nil{ Message } in Cons{ Message } msg nil_msg

  type Error =
    | CodeWrongCaller
    | CodeNotValid

  let make_error = fun( error: Error ) =>
    let result = match error with
    | CodeWrongCaller            => Int32 -1
    | CodeNotValid               => Int32 -2
    end in { _exception: "Error"; code: result }

  let zero = Uint128 0
  let yes = True
  let no = False
  let zeroAccount = let i = Pair{ Uint128 Bool } zero yes in Pair{ Uint128 ( Pair Uint128 Bool )} zero i
  
  let option_value = tfun 'A => fun( default: 'A ) => fun( input: Option 'A ) =>
    match input with
    | Some v => v
    | None => default
    end
  
  let option_uint128_value = let f = @option_value Uint128 in f zero
  
  let option_account = let f = @option_value ( Pair Uint128 ( Pair Uint128 Bool )) in f zeroAccount
    
  let account_balance = fun( getAccount: Option( Pair Uint128 ( Pair Uint128 Bool ))) =>
    let account = option_account getAccount
    in let fst_element = @fst Uint128 ( Pair Uint128 Bool )
    in fst_element account
    
  let account_share = fun( getAccount: Option( Pair Uint128 ( Pair Uint128 Bool ))) =>
    let account = option_account getAccount
    in let snd_element = @snd Uint128 ( Pair Uint128 Bool )
    in let data = snd_element account
    in let fst_element = @fst Uint128 Bool
    in fst_element data
  
  let account_vote = fun( getAccount: Option( Pair Uint128 ( Pair Uint128 Bool ))) =>
    let account = option_account getAccount
    in let snd_element = @snd Uint128 ( Pair Uint128 Bool )
    in let data = snd_element account
    in let data_snd_element = @snd Uint128 Bool
    in data_snd_element data
  
  let compare_member = fun( addr: ByStr20 ) => fun( member: ByStr20 ) => builtin eq addr member

contract PSTproxy(
  initAdmin: ByStr20,
  initDao: ByStr20,
  name: String,
  symbol: String,
  decimals: Uint32,
  initSupply: Uint128,
  f: Uint128
  (* to-do create and update f & t fields *)
  )
  with
    let string_is_not_empty = fun( s : String ) =>
      let zero = Uint32 0 
      in let s_length = builtin strlen s
      in let s_empty = builtin eq s_length zero
      in negb s_empty
    in let name_ok = string_is_not_empty name
    in let symbol_ok = string_is_not_empty symbol
    in let name_symbol_ok = andb name_ok symbol_ok
    in let decimals_ok =
      let six = Uint32 6
      in let eighteen = Uint32 18
      in let decimals_at_least_6 = uint32_le six decimals
      in let decimals_no_more_than_18 = uint32_le decimals eighteen
      in andb decimals_at_least_6 decimals_no_more_than_18
      in andb name_symbol_ok decimals_ok
  =>
  field admin: ByStr20 = initAdmin
  field dao: ByStr20 = initDao
  field implementation: ByStr20 = initAdmin
  field accounts: Map ByStr20 ( Pair Uint128 ( Pair Uint128 Bool )) = let emp_map = Emp ByStr20 ( Pair Uint128 ( Pair Uint128 Bool )) 
    in let i = Pair{ Uint128 Bool } f yes 
    in let init = Pair{ Uint128 ( Pair Uint128 Bool )} initSupply i 
    in builtin put emp_map initAdmin init
  field total_supply: Uint128 = initSupply
  field allowances: Map ByStr20 ( Map ByStr20 Uint128 ) = Emp ByStr20 ( Map ByStr20 Uint128 )
  field agents: List ByStr20 = let nil = Nil{ ByStr20 } in Cons{ ByStr20 } initAdmin nil
  field income: Uint128 = zero
  field subtotal: Uint128 = zero
  
procedure ThrowError(
  err: Error
  )
  e = make_error err; throw e
end

procedure VerifyCaller(
  addr: ByStr20
  )
  verified = builtin eq addr _sender;
  match verified with
  | True =>
  | False => err= CodeWrongCaller; ThrowError err
  end
end

(* ZRC-5 add native funds ($ZIL) to the contract's _balance *)
transition AddFunds()
  accept
end

transition UpgradeImplementation(
  newImplementation: ByStr20
  )
  current_admin <- admin; VerifyCaller current_admin;
  implementation := newImplementation;
  e = {
    _eventname: "ImplementationUpgraded";
    newImplementation: newImplementation
  }; event e
end

transition UpdateProxyAdmin(
  newAdmin: ByStr20
  )
  current_admin <- admin; VerifyCaller current_admin;
  admin := newAdmin;
  e = {
    _eventname: "AdminAddressUpdated";
    newAdmin: newAdmin
  }; event e
end

transition UpdateDaoAddr(
  newAddr: ByStr20
  )
  current_admin <- admin; VerifyCaller current_admin;
  dao := newAddr;
  e = {
    _eventname: "DaoAddressUpdated";
    newAddress: newAddr
  }; event e
end

transition UpdateImplementationAdmin(
  newAdmin: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "UpdateImplementationAdmin";
    _recipient: current_impl;
    _amount: zero;
    newAdmin: newAdmin
  } in one_msg m; send msg
end

transition UpdatePauser(
  newPauser: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "UpdatePauser";
    _recipient: current_impl;
    _amount: zero;
    newPauser: newPauser
  } in one_msg m; send msg
end

transition Pause()
  current_impl <- implementation;
  msg = let m = {
    _tag: "Pause";
    _recipient: current_impl;
    _amount: zero
  } in one_msg m; send msg
end

transition Unpause()
  current_impl <- implementation;
  msg = let m = {
    _tag: "Unpause";
    _recipient: current_impl;
    _amount: zero
  } in one_msg m; send msg
end

transition UpdateBlacklister(
  newBlacklister: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "UpdateBlacklister";
    _recipient: current_impl;
    _amount: zero;
    newBlacklister: newBlacklister
  } in one_msg m; send msg
end

transition Blacklist(
  addr: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "Blacklist";
    _recipient: current_impl;
    _amount: zero;
    addr: addr
  } in one_msg m; send msg
end

transition Unblacklist(
  addr: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "Unblacklist";
    _recipient: current_impl;
    _amount: zero;
    addr: addr
  } in one_msg m; send msg
end

transition UpdateMasterMinter(
  newMasterMinter: ByStr20
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "UpdateMasterMinter";
    _recipient: current_impl;
    _amount: zero;
    newMasterMinter: newMasterMinter
  } in one_msg m; send msg
end

transition IncreaseMinterAllowance(
  minter: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "IncreaseMinterAllowance";
    _recipient: current_impl;
    _amount: zero;
    minter: minter;
    amount: amount
  } in one_msg m; send msg
end

transition DecreaseMinterAllowance(
  minter: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  msg = let m = {
    _tag: "DecreaseMinterAllowance";
    _recipient: current_impl;
    _amount: zero;
    minter: minter;
    amount: amount
  } in one_msg m; send msg
end

transition Mint(
  beneficiary: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  current_supply <- total_supply;
  get_beneficiary_account <- accounts[beneficiary]; beneficiary_bal = account_balance get_beneficiary_account;
  msg = let m = {
    _tag: "Mint";
    _recipient: current_impl;
    _amount: zero;
    beneficiary: beneficiary;
    amount: amount;
    beneficiaryBal: beneficiary_bal;
    currentSupply: current_supply
  } in one_msg m; send msg
end

procedure UpdateAccount(
  addr: ByStr20,
  bal: Uint128
  )
  t <- total_supply;
  not_enough = let n = builtin div t f in builtin lt bal n;
  list_mem = @list_mem ByStr20;
  agents_list <- agents;
  is_member = list_mem compare_member addr agents_list;
  match not_enough with
  | True => 
      account = let data = Pair{ Uint128 Bool } zero yes in Pair{ Uint128 ( Pair Uint128 Bool )} bal data;
      accounts[addr] := account;
      match is_member with
      | True =>
          list_filter = @list_filter ByStr20;
          remove_member = fun( member: ByStr20 ) => let is_addr = builtin eq addr member in negb is_addr;
          agents_updated = list_filter remove_member agents_list;
          agents := agents_updated
      | False =>
      end
  | False =>
      account = 
        let data =
          let share = let ebal = builtin mul bal f in builtin div ebal t
          in Pair{ Uint128 Bool } share yes
        in Pair{ Uint128 ( Pair Uint128 Bool )} bal data;
      accounts[addr] := account;
      match is_member with
      | True =>
      | False =>
          agents_updated = Cons{ ByStr20 } addr agents_list;
          agents := agents_updated
      end
  end
end

transition MintCallBack(
  beneficiary: ByStr20,
  newBeneficiaryBal: Uint128,
  newSupply: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  UpdateAccount beneficiary newBeneficiaryBal;
  total_supply := newSupply
end

transition Burn(
  amount: Uint128
  )
  current_impl <- implementation;
  current_supply <- total_supply;
  get_minter_bal <- accounts[_sender]; minter_bal = account_balance get_minter_bal;
  msg = let m = {
    _tag: "Burn";
    _recipient: current_impl;
    _amount: zero;
    amount: amount;
    minterBal: minter_bal;
    currentSupply: current_supply
  } in one_msg m; send msg
end

transition BurnCallBack(
  newMinterBalance: Uint128,
  newSupply: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  UpdateAccount _origin newMinterBalance;
  total_supply := newSupply
end

transition LawEnforcementWipingBurn(
  addr: ByStr20
  )
  current_impl <- implementation;
  current_supply <- total_supply;
  get_account <- accounts[addr]; bal = account_balance get_account;
  msg = let m = {
    _tag: "LawEnforcementWipingBurn";
    _recipient: current_impl;
    _amount: zero;
    addr: addr;
    addrBal: bal;
    currentSupply: current_supply
  } in one_msg m; send msg
end

transition LawEnforcementWipingBurnCallBack(
  addr: ByStr20,
  newSupply: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  delete accounts[addr];
  total_supply := newSupply
end

transition IncreaseAllowance(
  spender: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  get_allowance <- allowances[_sender][spender]; allowance = option_uint128_value get_allowance;
  msg = let m = {
    _tag: "IncreaseAllowance";
    _recipient: current_impl;
    _amount: zero;
    originator: _sender;
    spender: spender;
    amount: amount;
    currentAllowance: allowance
  } in one_msg m; send msg
end

transition DecreaseAllowance(
  spender: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  get_allowance <- allowances[_sender][spender]; allowance = option_uint128_value get_allowance;
  msg = let m = {
    _tag: "DecreaseAllowance";
    _recipient: current_impl;
    _amount: zero;
    originator: _sender;
    spender: spender;
    amount: amount;
    currentAllowance: allowance
  } in one_msg m; send msg
end

transition AllowanceCallBack(
  originator: ByStr20,
  spender: ByStr20,
  newAllowance: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  allowances[originator][spender] := newAllowance
end

transition Transfer(
  to: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  get_originator_account <- accounts[_sender]; originator_bal = account_balance get_originator_account;
  get_beneficiary_account <- accounts[to]; beneficiary_bal = account_balance get_beneficiary_account;
  msg = let m = {
    _tag: "Transfer";
    _recipient: current_impl;
    _amount: zero;
    originator: _sender;
    beneficiary: to;
    amount: amount;
    originatorBal: originator_bal;
    beneficiaryBal: beneficiary_bal
  } in one_msg m; send msg
end

transition TransferCallBack(
  originator: ByStr20,
  beneficiary: ByStr20,
  newOriginatorBal: Uint128,
  newBeneficiaryBal: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  UpdateAccount originator newOriginatorBal;
  UpdateAccount beneficiary newBeneficiaryBal
end

transition TransferFrom(
  from: ByStr20, 
  to: ByStr20,
  amount: Uint128
  )
  current_impl <- implementation;
  get_beneficiary_account <- accounts[to]; beneficiary_bal = account_balance get_beneficiary_account;
  get_originator_account <- accounts[from]; originator_bal = account_balance get_originator_account;
  get_allowance <- allowances[from][_sender]; allowance = option_uint128_value get_allowance;
  msg = let m = {
    _tag: "TransferFrom";
    _recipient: current_impl;
    _amount: zero;
    originator: from;
    spender: _sender;
    beneficiary: to;
    amount: amount;
    originatorBal: originator_bal;
    spenderAllowance: allowance;
    beneficiaryBal: beneficiary_bal
  } in one_msg m; send msg
end

transition TransferFromCallBack(
  originator: ByStr20,
  beneficiary: ByStr20,
  newOriginatorBal: Uint128,
  newBeneficiaryBal: Uint128
  )
  current_impl <- implementation; VerifyCaller current_impl;
  UpdateAccount originator newOriginatorBal;
  UpdateAccount beneficiary newBeneficiaryBal
end

transition SwapZILForPSTAndShare(
  beneficiary: Option( List ByStr20 ),
  minPstAmount: Uint128,
  blockDeadline: Uint128
  )
  current_impl <- implementation; accept;
  msg = let m = {
    _tag: "SwapZILForPSTAndShare";
    _recipient: current_impl;
    _amount: _amount;
    minPstAmount: minPstAmount;
    originator: _sender;
    beneficiary: beneficiary;
    blockDeadline: blockDeadline
  } in one_msg m; send msg
end

procedure UpdateIncome(
  bal: Uint128
  )
  this_income = builtin div bal f;
  income := this_income
end

procedure DistributeProfit(
  beneficiary: ByStr20
  )
  get_account <- accounts[beneficiary]; bal = account_balance get_account; share = account_share get_account;
  this_income <- income;
  plus_profit_balance = let this_share = builtin mul this_income share in builtin add bal this_share;
  UpdateAccount beneficiary plus_profit_balance
end

procedure UpdateSubtotal(
  beneficiary: ByStr20
  )
  get_account <- accounts[beneficiary]; bal = account_balance get_account;
  current_subtotal <- subtotal;
  update_subtotal = builtin add current_subtotal bal;
  subtotal := update_subtotal
end

procedure DistributePST(
  beneficiary: ByStr20
  )
  get_account <- accounts[beneficiary]; bal = account_balance get_account;
  this_subtotal <- subtotal;
  this_income <- income;
  plus_income_balance = let ebal = builtin mul bal f in let share = builtin div ebal this_subtotal in let this_share = builtin mul this_income share in builtin add bal this_share;
  UpdateAccount beneficiary plus_income_balance
end

transition ProfitShareCallBack(
  originator: ByStr20,
  beneficiary: Option( List ByStr20 )
  )
  current_impl <- implementation; VerifyCaller current_impl;
  get_account <- accounts[originator]; bal = account_balance get_account;
  UpdateIncome bal;
  current_dao <- dao;
  is_dao = builtin eq originator current_dao;
  match is_dao with
  | True =>
      agents_list <- agents;
      forall agents_list DistributeProfit;
      get_dao_account <- accounts[current_dao]; plus_profit_bal = account_balance get_dao_account;
      burn = builtin sub plus_profit_bal bal;
      delete accounts[current_dao];
      current_supply <- total_supply;
      new_supply = builtin sub current_supply burn;
      total_supply := new_supply
  | False =>
      match beneficiary with
      | Some list =>
          subtotal := zero;
          forall list UpdateSubtotal;
          forall list DistributePST
      | None => err = CodeNotValid; ThrowError err
      end
  end
end