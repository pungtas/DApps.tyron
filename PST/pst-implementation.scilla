(*
PST ZRC: profit-sharing token Zilliqa reference contract - Implementation smart contract.
Tyron Self-Sovereign Identity Protocol.
Copyright (C) Tyron Pungtas and its affiliates.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*)

scilla_version 0

import BoolUtils IntUtils ListUtils

library PSTimplementation

let one_msg = fun( msg: Message ) =>
  let nil_msg = Nil{ Message } in Cons{ Message } msg nil_msg

let two_msgs = fun( msg1: Message ) => fun( msg2: Message ) =>
  let msgs_tmp = one_msg msg2 in Cons{ Message } msg1 msgs_tmp

let three_msgs = fun( msg1: Message ) => fun( msg2: Message ) => fun( msg3: Message ) =>
  let msgs_tmp = two_msgs msg2 msg3 in Cons{ Message } msg1 msgs_tmp

let four_msgs = fun( msg1: Message ) => fun( msg2: Message ) => fun( msg3: Message ) => fun( msg4: Message ) =>
  let msgs_tmp = three_msgs msg2 msg3 msg4 in Cons{ Message } msg1 msgs_tmp

type Error =
  | CodeNotRightCaller
  | CodeIsSender
  | CodeInsufficientFunds
  | CodeInsufficientAllowance
  | CodeNotAdmin
  | CodeNotPauser
  | CodeNotBlacklister
  | CodeNotMasterMinter
  | CodeNotMinter
  | CodeIsNull
  | ThrowIfZero
  | CodeIsPaused
  | CodeNotPaused
  | CodeIsBlacklisted
  | CodeNotBlacklisted

let make_error = fun( error: Error ) =>
  let result = match error with
  | CodeNotRightCaller                => Int32 -1
  | CodeIsSender                      => Int32 -2
  | CodeInsufficientFunds             => Int32 -2
  | CodeInsufficientAllowance         => Int32 -4
  | CodeNotAdmin                      => Int32 -5
  | CodeNotPauser                     => Int32 -6
  | CodeNotBlacklister                => Int32 -7
  | CodeNotMasterMinter               => Int32 -8
  | CodeNotMinter                     => Int32 -9
  | CodeIsNull                        => Int32 -10
  | CodeIsPaused                      => Int32 -11
  | CodeNotPaused                     => Int32 -12
  | CodeIsBlacklisted                 => Int32 -13
  | CodeNotBlacklisted                => Int32 -14
  | ThrowIfZero                       => Int32 -15
  end in { _exception: "Error"; code: result }

let zero = Uint128 0
let one  = Uint128 1
let hundred = Uint128 100
let none_uint128 = None{ Uint128 }
let true = True
let false = False
let null_address = 0x0000000000000000000000000000000000000000

let option_value = tfun 'A => fun( default: 'A ) => fun( opt_val: Option 'A ) =>
  match opt_val with
  | Some v => v
  | None => default
  end

let option2_uint128_value = fun( input: Option( Option Uint128 )) =>
  match input with
  | Some (Some a) => a
  | _ => zero
  end

let option_uint128 = fun( input: Uint128 ) =>
  let is_zero = builtin eq input zero in
  match is_zero with
  | True => None{ Uint128 }
  | False => Some{ Uint128 } input
  end

let better_subtract = fun( a: Uint128 ) => fun( b: Uint128 ) =>
  let a_ge_b = uint128_ge a b in
  match a_ge_b with
  | True => builtin sub a b
  | False => zero
  end

contract PSTimplementation(
  initAdmin: ByStr20,
  proxyAddr: ByStr20,
  zilswapAddr: ByStr20
  )
  field admin: ByStr20 = initAdmin
  field pauser: ByStr20 = initAdmin
  field master_minter: ByStr20 = initAdmin
  field paused: Bool = True
  field blacklister: ByStr20 = initAdmin
  field blacklisted: Map ByStr20 Uint128 = Emp ByStr20 Uint128
  field minter_allowances: Map ByStr20 ( Option Uint128 ) = Emp ByStr20 ( Option Uint128 )
  field zilswap: ByStr20 = zilswapAddr
  field block_period: Uint128 = zero
  field deadline_block: BNum = BNum 0

procedure ThrowError(
  err: Error
  )
  e = make_error err; throw e
end

(* Validate given address against _sender *)
procedure VerifyProxy()
  verified = builtin eq proxyAddr _sender;
  match verified with
  | True =>
  | False => err= CodeNotRightCaller; ThrowError err
  end
end

procedure isAdmin(
  addr: ByStr20
  )
  current_admin <- admin;
  is_admin = builtin eq current_admin addr;
  match is_admin with
  | True =>
  | False => err = CodeNotAdmin; ThrowError err
  end
end

procedure isPauser(
  addr: ByStr20
  )
  current_pauser <- pauser;
  is_pauser = builtin eq current_pauser addr;
  match is_pauser with
  | True  =>
  | False => err = CodeNotPauser; ThrowError err
  end
end

procedure isPaused()
  is_paused <- paused;
  match is_paused with
  | True =>
  | False => err = CodeNotPaused; ThrowError err
  end
end

procedure isNotPaused()
  is_paused <- paused;
  match is_paused with
  | True => err = CodeIsPaused; ThrowError err
  | False =>
  end
end

procedure isBlacklister(
  addr: ByStr20
  )
  current_blacklister <- blacklister;
  is_blacklister = builtin eq current_blacklister addr;
  match is_blacklister with
  | True  =>
  | False => err = CodeNotBlacklister; ThrowError err
  end
end

procedure isBlacklisted(
  addr: ByStr20
  )
  is_blacklisted <- exists blacklisted[addr];
  match is_blacklisted with
  | True =>
  | False => err = CodeNotBlacklisted; ThrowError err
  end
end

procedure isNotBlacklisted(
  addr: ByStr20
  )
  is_blacklisted <- exists blacklisted[addr];
  match is_blacklisted with
  | True => err = CodeIsBlacklisted; ThrowError err
  | False =>
  end
end

procedure isMasterMinter(
  addr: ByStr20
  )
  current_master_minter <- master_minter;
  is_master_minter = builtin eq current_master_minter addr;
  match is_master_minter with
  | True  =>
  | False => err = CodeNotMasterMinter; ThrowError err
  end
end

procedure isMinter(
  addr: ByStr20
  )
  is_minter <- minter_allowances[addr];
  match is_minter with
  | Some( Some allowance )  =>
  | _ => err = CodeNotMinter; ThrowError err
  end
end

procedure isNotNull(
  addr: ByStr20
  )
  is_null = builtin eq null_address addr;
  match is_null with
  | True => err = CodeIsNull; ThrowError err
  | False =>
  end
end

procedure ThrowIfZero(
  amount: Uint128
  )
  gt_zero = uint128_gt amount zero;
  match gt_zero with
  | True =>
  | False => err = ThrowIfZero; ThrowError err
  end
end

procedure isNotSender(
  a: ByStr20,
  b: ByStr20
  )
  is_self = builtin eq a b;
  match is_self with
  | True => err = CodeIsSender; ThrowError err
  | False =>
  end
end

procedure isSufficientFunds(
  funds: Uint128,
  amount: Uint128
  )
  sufficient_funds = uint128_ge funds amount;
  match sufficient_funds with
  | True =>
  | False => err = CodeInsufficientFunds; ThrowError err
  end
end

procedure isSufficientAllowance(
  allowance: Uint128,
  amount: Uint128
  )
  sufficient_allowance = uint128_ge allowance amount;
  match sufficient_allowance with
  | True =>
  | False => err = CodeInsufficientAllowance; ThrowError err
  end
end

transition UpdateImplementationAdmin(
  newAdmin: ByStr20,
  initiator: ByStr20
  )
  VerifyProxy;
  isAdmin initiator;
  isNotNull newAdmin;
  current_admin <- admin;
  isNotSender current_admin newAdmin;
  admin := newAdmin;
  e = {
    _eventname: "AdminUpdated";
    from: current_admin;
    to: newAdmin
  }; event e
end

transition UpdatePauser(
  newPauser: ByStr20,
  initiator: ByStr20
  )
  VerifyProxy;
  isAdmin initiator;
  isNotNull newPauser;
  current_pauser <- pauser;
  isNotSender current_pauser newPauser;
  pauser := newPauser;
  e = {
    _eventname: "PauserUpdated";
    pauser: newPauser;
    executor: initiator
  }; event e
end

transition Pause(
  initiator: ByStr20
  )
  VerifyProxy;
  isPauser initiator;
  isNotPaused;
  paused := true;
  e = {
    _eventname: "Paused";
    executor: initiator
  }; event e
end

transition Unpause(
  initiator: ByStr20
  )
  VerifyProxy;
  isPauser initiator;
  isPaused;
  paused := false;
  e = {
    _eventname: "Unpaused";
    executor: initiator
  }; event e
end

transition UpdateBlacklister(
  newBlacklister: ByStr20, 
  initiator: ByStr20
  )
  VerifyProxy;
  isAdmin initiator;
  isNotNull newBlacklister;
  current_blacklister <- blacklister;
  isNotSender current_blacklister newBlacklister;
  blacklister:= newBlacklister;
  e = {
    _eventname: "BlacklisterUpdated";
    blacklister: newBlacklister;
    executor: initiator
  }; event e
end

transition Blacklist(
  addr: ByStr20,
  initiator: ByStr20
  )
  VerifyProxy;
  isBlacklister initiator;
  isNotNull addr;
  isNotBlacklisted addr;
  blacklisted[addr] := one;
  e = {
    _eventname: "Blacklisted";
    address: addr;
    executor: initiator
  }; event e
end

transition Unblacklist(
  addr: ByStr20,
  initiator: ByStr20
  )
  VerifyProxy;
  isBlacklister initiator;
  isNotNull addr;
  isBlacklisted addr;
  delete blacklisted[addr];
  e = {
    _eventname: "Unblacklisted";
    address: addr;
    executor: initiator
  }; event e
end

transition UpdateMasterMinter(
  newMasterMinter: ByStr20,
  initiator: ByStr20
  )
  VerifyProxy;
  isAdmin initiator;
  isNotNull newMasterMinter;
  current_master_minter <- master_minter;
  isNotSender current_master_minter newMasterMinter;
  master_minter := newMasterMinter;
  e = {
    _eventname: "MasterMinterUpdated";
    masterMinter: newMasterMinter;
    executor: initiator
  }; event e
end

transition IncreaseMinterAllowance(
  minter: ByStr20,
  amount: Uint128,
  initiator: ByStr20
  )
  VerifyProxy;
  isMasterMinter initiator;
  isNotNull minter;
  get_minter_allowance <- minter_allowances[minter];
  minter_allowance = option2_uint128_value get_minter_allowance;
  new_minter_allowance = builtin add minter_allowance amount;
  new_option_minter_allowance = option_uint128 new_minter_allowance;
  minter_allowances[minter] := new_option_minter_allowance;
  e = {
    _eventname: "IncreasedMinterAllowance";
    minter: minter;
    newAllowance: new_minter_allowance;
    executor: initiator
  }; event e
end

transition DecreaseMinterAllowance(
  minter: ByStr20,
  amount: Uint128,
  initiator: ByStr20
  )
  VerifyProxy;
  isMasterMinter initiator;
  isNotNull minter;
  get_minter_allowance <- minter_allowances[minter];
  minter_allowance = option2_uint128_value get_minter_allowance;
  new_minter_allowance = better_subtract minter_allowance amount;
  new_option_minter_allowance = option_uint128 new_minter_allowance;
  minter_allowances[minter] := new_option_minter_allowance;
  e = {
    _eventname: "DecreasedMinterAllowance";
    minter: minter;
    newAllowance : new_option_minter_allowance;
    executor: initiator
  }; event e
end

transition Mint(
  to: ByStr20,
  amount: Uint128,
  toBal: Uint128,
  currentSupply: Uint128,
  initiator: ByStr20
  )
  VerifyProxy;
  isNotPaused;
  isMinter initiator;
  isNotBlacklisted initiator;
  isNotBlacklisted to;
  isNotNull to;
  get_minter_allowance <- minter_allowances[initiator];
  minter_allowance = option2_uint128_value get_minter_allowance;
  isSufficientAllowance minter_allowance amount;
  new_supply = builtin add amount currentSupply;
  new_to_bal = builtin add amount toBal;
  new_minter_allowance = better_subtract minter_allowance amount;
  new_option_minter_allowance = option_uint128 new_minter_allowance;
  minter_allowances[initiator] := new_option_minter_allowance;
  e = {
    _eventname: "Minted";
    minter: initiator;
    amount: amount;
    recipient: to
  }; event e;
  msg_to_proxy = {
    _tag: "MintCallBack";
    _recipient: _sender;
    _amount: zero;
    to: to;
    newToBal: new_to_bal;
    newSupply: new_supply
  };
  msg_to_sender = {
    _tag: "MintSuccessCallBack";
    _recipient: initiator;
    _amount: zero;
    recipient: to;
    amount: amount
  };
  msg_to_recipient = {
    _tag: "RecipientAcceptMint";
    _recipient: to;
    _amount: zero;
    recipient: to;
    amount: amount
  };
  msgs = three_msgs msg_to_proxy msg_to_sender msg_to_recipient; send msgs
end

transition Burn(
  amount: Uint128,
  initiator: ByStr20,
  initiatorBal: Uint128, 
  currentSupply: Uint128
  )
  VerifyProxy;
  isNotPaused;
  isMinter initiator;
  isNotBlacklisted initiator;
  isSufficientFunds initiatorBal amount;
  new_minter_balance = builtin sub initiatorBal amount;
  new_supply = builtin sub currentSupply amount;
  e = {
    _eventname: "Burnt";
    executor: initiator;
    amount: amount
  }; event e;
  msg_to_proxy = {
    _tag: "BurnCallBack";
    _recipient: _sender;
    _amount: zero;
    initiator: initiator;
    newMinterBalance: new_minter_balance;
    newSupply: new_supply
  };
  msg_to_sender = {
    _tag: "BurnSuccessCallBack";
    _recipient: initiator;
    _amount: zero;
    sender: initiator;
    amount: amount
  };
  msgs = two_msgs msg_to_proxy msg_to_sender; send msgs
end

transition LawEnforcementWipingBurn(
  addr: ByStr20,
  addrBal: Uint128,
  currentSupply: Uint128,
  initiator: ByStr20
  )
  VerifyProxy;
  isNotPaused;
  isBlacklisted addr;
  isBlacklister initiator;
  isNotBlacklisted initiator;
  e = {
    _eventname: "LawEnforcementWipingBurnt";
    blacklister: initiator;
    address: addr;
    amount: addrBal
  }; event e;
  new_supply = builtin sub currentSupply addrBal;
  msg_to_proxy = {
    _tag: "LawEnforcementWipingBurnCallBack";
    _recipient: _sender;
    _amount: zero;
    addr: addr;
    newSupply : new_supply
  };
  msg_to_sender = {
    _tag: "LawEnforcementWipingBurnSuccessCallBack";
    _recipient: initiator;
    _amount: zero;
    addr: addr
  };
  msgs = two_msgs msg_to_proxy msg_to_sender;
  send msgs
end

transition IncreaseAllowance(
  spender: ByStr20,
  amount: Uint128,
  currentAllowance: Uint128,
  initiator: ByStr20
  )
  VerifyProxy;
  isNotPaused;
  isNotBlacklisted initiator;
  isNotBlacklisted spender;
  isNotSender initiator spender;
  new_allowance = builtin add currentAllowance amount;
  e = {
    _eventname: "IncreasedAllowance";
    ssi: initiator;
    spender: spender;
    newAllowance : new_allowance
  }; event e;
  msg = let m = {
    _tag: "AllowanceCallBack";
    _recipient: _sender;
    _amount: zero;
    initiator: initiator;
    spender: spender;
    newAllowance: new_allowance
  } in one_msg m; send msg
end

transition DecreaseAllowance(
  spender: ByStr20,
  amount: Uint128,
  initiator: ByStr20,
  currentAllowance: Uint128
  )
  VerifyProxy;
  isNotPaused;
  isNotBlacklisted initiator;
  isNotBlacklisted spender;
  isNotSender initiator spender;
  new_allowance = better_subtract currentAllowance amount;
  e = {
    _eventname: "DecreasedAllowance";
    ssi: initiator;
    spender: spender;
    newAllowance: new_allowance
  }; event e;
  msg = let m = {
    _tag: "AllowanceCallBack";
    _recipient: _sender;
    _amount: zero;
    initiator: initiator;
    spender: spender;
    new_allowance: new_allowance
  } in one_msg m; send msg
end

transition Transfer(
  to: ByStr20,
  amount: Uint128,
  initiator: ByStr20,
  fromBal: Uint128,
  toBal: Uint128
  )
  VerifyProxy;
  isNotPaused;
  isNotBlacklisted initiator;
  isNotBlacklisted to;
  isNotSender initiator to;
  isNotNull to;
  isSufficientFunds fromBal amount;
  new_from_bal = builtin sub fromBal amount;
  new_to_bal = builtin add toBal amount;
  e = {
    _eventname: "TransferSuccess";
    originator: initiator;
    beneficiary: to;
    amount: amount
  }; event e;
  msg_to_proxy = {
    _tag: "TransferCallBack";
    _recipient: _sender;
    _amount: zero;
    from: fromBal;
    newFromBal: new_from_bal;
    to: to;
    newToBal: new_to_bal
  };
  msg_to_sender = {
    _tag: "TransferSuccessCallBack";
    _recipient: initiator;
    _amount: zero;
    sender: initiator;
    recipient: to;
    amount: amount
  };
  msg_to_recipient = {
    _tag: "RecipientAcceptTransfer";
    _recipient: to;
    _amount: zero;
    sender: initiator;
    recipient: to;
    amount: amount
  };
  msgs = three_msgs msg_to_proxy msg_to_sender msg_to_recipient;
  send msgs
end

transition TransferFrom(
  from: ByStr20,
  to: ByStr20, 
  amount: Uint128,
  initiator: ByStr20,
  fromBal: Uint128,
  spenderAllowance: Uint128,
  toBal: Uint128
  )
  VerifyProxy;
  isNotPaused;
  isNotBlacklisted initiator;
  isNotBlacklisted to;
  isNotBlacklisted from;
  isNotSender from to;
  isNotNull to;
  isSufficientFunds fromBal amount;
  isSufficientAllowance spenderAllowance amount;
  new_from_bal = builtin sub fromBal amount;
  new_to_bal = builtin add toBal amount;
  new_spender_allowance = builtin sub spenderAllowance amount;
  e = {
    _eventname: "TransferFromSuccess";
    initiator: initiator;
    sender: from;
    recipient: to;
    amount: amount
  }; event e;
  msg_to_proxy_balances = {
    _tag: "TransferFromCallBack";
    _recipient: _sender;
    _amount: zero;
    from: from;
    to: to;
    newFromBal: new_from_bal;
    newToBal: new_to_bal
  };
  msg_to_proxy_allowance = {
    _tag: "AllowanceCallBack";
    _recipient: _sender;
    _amount: zero;
    initiator: from;
    spender: initiator;
    new_allowance: new_spender_allowance
  };
  msg_to_sender = {
    _tag: "TransferFromSuccessCallBack";
    _recipient: initiator;
    _amount: zero;
    initiator: initiator;
    sender: from;
    recipient: to;
    amount: amount
  };
  msg_to_recipient = {
    _tag: "RecipientAcceptTransferFrom";
    _recipient: to;
    _amount: zero;
    initiator: initiator;
    sender: from;
    recipient: to;
    amount: amount
  };
  msgs = four_msgs msg_to_proxy_balances msg_to_proxy_allowance msg_to_sender msg_to_recipient;
  send msgs
end

transition UpdateZilswap(
  newAddr: ByStr20
  )
  VerifyProxy;
  zilswap := newAddr
end

procedure UpdateDeadline()
  current_block <- &BLOCKNUMBER;
  blocks <- block_period;
  deadline = builtin badd current_block blocks;
  deadline_block := deadline
end

transition UpdateBlockPeriod(
  blocks: Uint128
  )
  VerifyProxy;
  block_period := blocks
end

transition SwapZILForPST(
  minPstAmount: Uint128
  )
  VerifyProxy;
  zilswap_addr <- zilswap; accept;
  UpdateDeadline; deadline <- deadline_block;
  msg = let m = {
    _tag: "SwapExactZILForTokens";
    _recipient: zilswap_addr;
    _amount: _amount;
    token_address: proxyAddr;
    min_token_amount: minPstAmount;
    deadline_block: deadline;
    recipient_address: _this_address
  } in one_msg m; send msg
end

transition RecipientAcceptTransfer(
  sender: ByStr20,
  recipient: ByStr20,
  amount: Uint128
  )
end
