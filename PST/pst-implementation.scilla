(*
  PST ZRC: profit-sharing token Zilliqa reference contract - Implementation smart contract.
  Tyron Self-Sovereign Identity Protocol.
  Copyright (C) Tyron Pungtas and its affiliates.

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
*)

scilla_version 0

import BoolUtils IntUtils ListUtils

library PSTimplementation

  let one_msg = fun( msg: Message ) =>
    let nil_msg = Nil{ Message } in Cons{ Message } msg nil_msg

  let two_msgs = fun( msg1: Message ) => fun( msg2: Message ) =>
    let msgs_tmp = one_msg msg2 in Cons{ Message } msg1 msgs_tmp

  let three_msgs = fun( msg1: Message ) => fun( msg2: Message ) => fun( msg3: Message ) =>
    let msgs_tmp = two_msgs msg2 msg3 in Cons{ Message } msg1 msgs_tmp

  let four_msgs = fun( msg1: Message ) => fun( msg2: Message ) => fun( msg3: Message ) => fun( msg4: Message ) =>
    let msgs_tmp = three_msgs msg2 msg3 msg4 in Cons{ Message } msg1 msgs_tmp

  type Error =
    | CodeNotRightCaller
    | CodeIsSender
    | CodeInsufficientFunds
    | CodeInsufficientAllowance
    | CodeNotAdmin
    | CodeNotPauser
    | CodeNotBlacklister
    | CodeNotMasterMinter
    | CodeNotMinter
    | CodeIsNull
    | ThrownIfZero
    | CodeIsPaused
    | CodeNotPaused
    | CodeIsBlacklisted
    | CodeNotBlacklisted

  let make_error = fun( error: Error ) =>
    let result = match error with
    | CodeNotRightCaller                => Int32 -1
    | CodeIsSender                      => Int32 -2
    | CodeInsufficientFunds             => Int32 -3
    | CodeInsufficientAllowance         => Int32 -4
    | CodeNotAdmin                      => Int32 -5
    | CodeNotPauser                     => Int32 -6
    | CodeNotBlacklister                => Int32 -7
    | CodeNotMasterMinter               => Int32 -8
    | CodeNotMinter                     => Int32 -9
    | CodeIsNull                        => Int32 -10
    | CodeIsPaused                      => Int32 -11
    | CodeNotPaused                     => Int32 -12
    | CodeIsBlacklisted                 => Int32 -13
    | CodeNotBlacklisted                => Int32 -14
    | ThrownIfZero                       => Int32 -15
    end in { _exception: "Error"; code: result }

  let zero = Uint128 0
  let one  = Uint128 1
  let hundred = Uint128 100
  let none_uint128 = None{ Uint128 }
  let true = True
  let false = False
  let null_address = 0x0000000000000000000000000000000000000000

  let option_value = tfun 'A => fun( default: 'A ) => fun( opt_val: Option 'A ) =>
    match opt_val with
    | Some v => v
    | None => default
    end

  let option2_uint128_value = fun( input: Option( Option Uint128 )) =>
    match input with
    | Some (Some a) => a
    | _ => zero
    end

  let option_uint128 = fun( input: Uint128 ) =>
    let is_zero = builtin eq input zero in
    match is_zero with
    | True => None{ Uint128 }
    | False => Some{ Uint128 } input
    end

  let better_subtract = fun( a: Uint128 ) => fun( b: Uint128 ) =>
    let a_ge_b = uint128_ge a b in
    match a_ge_b with
    | True => builtin sub a b
    | False => zero
    end

contract PSTimplementation(
  initAdmin: ByStr20,
  proxyAddr: ByStr20,
  zilswapAddr: ByStr20
  )
  field admin: ByStr20 = initAdmin
  field pauser: ByStr20 = initAdmin
  field master_minter: ByStr20 = initAdmin
  field paused: Bool = False
  field blacklister: ByStr20 = initAdmin
  field blacklisted: Map ByStr20 Uint128 = Emp ByStr20 Uint128
  field minter_allowances: Map ByStr20 ( Option Uint128 ) = Emp ByStr20 ( Option Uint128 )
  field zilswap: ByStr20 = zilswapAddr
  field deadline_block: BNum = BNum 0

procedure ThrowError(
  err: Error
  )
  e = make_error err; throw e
end

procedure ThrowIfNotProxy()
  verified = builtin eq proxyAddr _sender;
  match verified with
  | True =>
  | False => err= CodeNotRightCaller; ThrowError err
  end
end

procedure isAdmin()
  current_admin <- admin;
  is_admin = builtin eq current_admin _origin;
  match is_admin with
  | True =>
  | False => err = CodeNotAdmin; ThrowError err
  end
end

procedure isPauser()
  current_pauser <- pauser;
  is_pauser = builtin eq current_pauser _origin;
  match is_pauser with
  | True  =>
  | False => err = CodeNotPauser; ThrowError err
  end
end

procedure isPaused()
  is_paused <- paused;
  match is_paused with
  | True =>
  | False => err = CodeNotPaused; ThrowError err
  end
end

procedure isNotPaused()
  is_paused <- paused;
  match is_paused with
  | True => err = CodeIsPaused; ThrowError err
  | False =>
  end
end

procedure isBlacklister()
  current_blacklister <- blacklister;
  is_blacklister = builtin eq current_blacklister _origin;
  match is_blacklister with
  | True  =>
  | False => err = CodeNotBlacklister; ThrowError err
  end
end

procedure isBlacklisted(
  addr: ByStr20
  )
  is_blacklisted <- exists blacklisted[addr];
  match is_blacklisted with
  | True =>
  | False => err = CodeNotBlacklisted; ThrowError err
  end
end

procedure isNotBlacklisted(
  addr: ByStr20
  )
  is_blacklisted <- exists blacklisted[addr];
  match is_blacklisted with
  | True => err = CodeIsBlacklisted; ThrowError err
  | False =>
  end
end

procedure isMasterMinter()
  current_master_minter <- master_minter;
  is_master_minter = builtin eq current_master_minter _origin;
  match is_master_minter with
  | True  =>
  | False => err = CodeNotMasterMinter; ThrowError err
  end
end

procedure isMinter()
  is_minter <- minter_allowances[_origin];
  match is_minter with
  | Some( Some allowance )  =>
  | _ => err = CodeNotMinter; ThrowError err
  end
end

procedure isNotNull(
  addr: ByStr20
  )
  is_null = builtin eq null_address addr;
  match is_null with
  | True => err = CodeIsNull; ThrowError err
  | False =>
  end
end

procedure ThrowIfZero(
  amount: Uint128
  )
  gt_zero = uint128_gt amount zero;
  match gt_zero with
  | True =>
  | False => err = ThrownIfZero; ThrowError err
  end
end

procedure isNotSender(
  a: ByStr20,
  b: ByStr20
  )
  is_self = builtin eq a b;
  match is_self with
  | True => err = CodeIsSender; ThrowError err
  | False =>
  end
end

procedure isSufficientFunds(
  funds: Uint128,
  amount: Uint128
  )
  sufficient_funds = uint128_ge funds amount;
  match sufficient_funds with
  | True =>
  | False => err = CodeInsufficientFunds; ThrowError err
  end
end

procedure isSufficientAllowance(
  allowance: Uint128,
  amount: Uint128
  )
  sufficient_allowance = uint128_ge allowance amount;
  match sufficient_allowance with
  | True =>
  | False => err = CodeInsufficientAllowance; ThrowError err
  end
end

transition UpdateImplementationAdmin(
  newAdmin: ByStr20
  )
  ThrowIfNotProxy; isAdmin;
  isNotPaused; isNotNull newAdmin;
  current_admin <- admin;
  isNotSender current_admin newAdmin;
  admin := newAdmin;
  e = {
    _eventname: "AdminUpdated";
    previousAdmin: current_admin;
    newAdmin: newAdmin
  }; event e
end

transition UpdatePauser(
  newPauser: ByStr20
  )
  ThrowIfNotProxy; isAdmin;
  isNotPaused; isNotNull newPauser;
  current_pauser <- pauser;
  isNotSender current_pauser newPauser;
  pauser := newPauser;
  e = {
    _eventname: "PauserUpdated";
    pauser: newPauser;
    admin: _origin
  }; event e
end

transition Pause()
  ThrowIfNotProxy; isPauser;
  isNotPaused; paused := true;
  e = {
    _eventname: "Paused";
    pauser: _origin
  }; event e
end

transition Unpause()
  ThrowIfNotProxy; isPauser;
  isPaused; paused := false;
  e = {
    _eventname: "Unpaused";
    pauser: _origin
  }; event e
end

transition UpdateBlacklister(
  newBlacklister: ByStr20
  )
  ThrowIfNotProxy; isAdmin;
  isNotPaused; isNotNull newBlacklister;
  current_blacklister <- blacklister;
  isNotSender current_blacklister newBlacklister; blacklister:= newBlacklister;
  e = {
    _eventname: "BlacklisterUpdated";
    blacklister: newBlacklister;
    admin: _origin
  }; event e
end

transition Blacklist(
  addr: ByStr20
  )
  ThrowIfNotProxy; isBlacklister;
  isNotPaused; isNotNull addr; isNotBlacklisted addr; blacklisted[addr] := one;
  e = {
    _eventname: "Blacklisted";
    address: addr;
    blacklister: _origin
  }; event e
end

transition Unblacklist(
  addr: ByStr20
  )
  ThrowIfNotProxy; isBlacklister;
  isNotPaused; isNotNull addr; isBlacklisted addr; delete blacklisted[addr];
  e = {
    _eventname: "Unblacklisted";
    address: addr;
    blacklister: _origin
  }; event e
end

transition UpdateMasterMinter(
  newMasterMinter: ByStr20
  )
  ThrowIfNotProxy; isAdmin;
  isNotPaused; isNotNull newMasterMinter;
  current_master_minter <- master_minter;
  isNotSender current_master_minter newMasterMinter; master_minter := newMasterMinter;
  e = {
    _eventname: "MasterMinterUpdated";
    newMasterMinter: newMasterMinter;
    admin: _origin
  }; event e
end

transition IncreaseMinterAllowance(
  minter: ByStr20,
  amount: Uint128
  )
  ThrowIfNotProxy; isMasterMinter;
  isNotPaused; isNotNull minter;
  get_minter_allowance <- minter_allowances[minter]; minter_allowance = option2_uint128_value get_minter_allowance;
  new_minter_allowance = builtin add minter_allowance amount; new_option_minter_allowance = option_uint128 new_minter_allowance;
  minter_allowances[minter] := new_option_minter_allowance;
  e = {
    _eventname: "IncreasedMinterAllowance";
    minter: minter;
    newAllowance: new_minter_allowance;
    masterMinter: _origin
  }; event e
end

transition DecreaseMinterAllowance(
  minter: ByStr20,
  amount: Uint128
  )
  ThrowIfNotProxy; isMasterMinter;
  isNotPaused; isNotNull minter;
  get_minter_allowance <- minter_allowances[minter]; minter_allowance = option2_uint128_value get_minter_allowance;
  new_minter_allowance = better_subtract minter_allowance amount; new_option_minter_allowance = option_uint128 new_minter_allowance;
  minter_allowances[minter] := new_option_minter_allowance;
  e = {
    _eventname: "DecreasedMinterAllowance";
    minter: minter;
    newAllowance : new_option_minter_allowance;
    masterMinter: _origin
  }; event e
end

transition Mint(
  beneficiary: ByStr20,
  amount: Uint128,
  beneficiaryBal: Uint128,
  currentSupply: Uint128
  )
  ThrowIfNotProxy; isMinter;
  isNotPaused; isNotBlacklisted _origin; isNotBlacklisted beneficiary; isNotNull beneficiary;
  get_minter_allowance <- minter_allowances[_origin]; minter_allowance = option2_uint128_value get_minter_allowance; isSufficientAllowance minter_allowance amount;
  new_supply = builtin add amount currentSupply;
  new_beneficiary_bal = builtin add amount beneficiaryBal;
  new_minter_allowance = better_subtract minter_allowance amount; new_option_minter_allowance = option_uint128 new_minter_allowance;
  minter_allowances[_origin] := new_option_minter_allowance;
  e = {
    _eventname: "Minted";
    minter: _origin;
    amount: amount;
    beneficiary: beneficiary
  }; event e;
  msg_to_proxy = {
    _tag: "MintCallBack";
    _recipient: _sender;
    _amount: zero;
    beneficiary: beneficiary;
    newBeneficiaryBal: new_beneficiary_bal;
    newSupply: new_supply
  };
  msg_to_minter = {
    _tag: "MintSuccessCallBack";
    _recipient: _origin;
    _amount: zero;
    beneficiary: beneficiary;
    amount: amount
  };
  msg_to_beneficiary = {
    _tag: "RecipientAcceptMint";
    _recipient: beneficiary;
    _amount: zero;
    minter: _origin;
    amount: amount
  };
  msgs = three_msgs msg_to_proxy msg_to_minter msg_to_beneficiary; send msgs
end

transition Burn(
  amount: Uint128,
  minterBal: Uint128, 
  currentSupply: Uint128
  )
  ThrowIfNotProxy; isMinter;
  isNotPaused; isNotBlacklisted _origin;
  isSufficientFunds minterBal amount;
  new_minter_balance = builtin sub minterBal amount;
  new_supply = builtin sub currentSupply amount;
  e = {
    _eventname: "Burnt";
    minter: _origin;
    amount: amount
  }; event e;
  msg_to_proxy = {
    _tag: "BurnCallBack";
    _recipient: _sender;
    _amount: zero;
    newMinterBalance: new_minter_balance;
    newSupply: new_supply
  };
  msg_to_sender = {
    _tag: "BurnSuccessCallBack";
    _recipient: _origin;
    _amount: zero;
    amount: amount
  };
  msgs = two_msgs msg_to_proxy msg_to_sender; send msgs
end

transition LawEnforcementWipingBurn(
  addr: ByStr20,
  addrBal: Uint128,
  currentSupply: Uint128
  )
  ThrowIfNotProxy; isBlacklister;
  isNotPaused; isBlacklisted addr; isNotBlacklisted _origin;
  e = {
    _eventname: "LawEnforcementWipingBurnt";
    blacklister: _origin;
    address: addr;
    amount: addrBal
  }; event e;
  new_supply = builtin sub currentSupply addrBal;
  msg_to_proxy = {
    _tag: "LawEnforcementWipingBurnCallBack";
    _recipient: _sender;
    _amount: zero;
    addr: addr;
    newSupply : new_supply
  };
  msg_to_sender = {
    _tag: "LawEnforcementWipingBurnSuccessCallBack";
    _recipient: _origin;
    _amount: zero;
    addr: addr
  };
  msgs = two_msgs msg_to_proxy msg_to_sender;
  send msgs
end

transition IncreaseAllowance(
  originator: ByStr20,
  spender: ByStr20,
  amount: Uint128,
  currentAllowance: Uint128
  )
  ThrowIfNotProxy;
  isNotPaused; isNotBlacklisted originator; isNotBlacklisted spender; isNotSender originator spender;
  new_allowance = builtin add currentAllowance amount;
  e = {
    _eventname: "IncreasedAllowance";
    originator: originator;
    spender: spender;
    newAllowance : new_allowance
  }; event e;
  msg = let m = {
    _tag: "AllowanceCallBack";
    _recipient: _sender;
    _amount: zero;
    originator: originator;
    spender: spender;
    newAllowance: new_allowance
  } in one_msg m; send msg
end

transition DecreaseAllowance(
  originator: ByStr20,
  spender: ByStr20,
  amount: Uint128,
  currentAllowance: Uint128
  )
  ThrowIfNotProxy;
  isNotPaused; isNotBlacklisted originator; isNotBlacklisted spender; isNotSender originator spender;
  new_allowance = better_subtract currentAllowance amount;
  e = {
    _eventname: "DecreasedAllowance";
    originator: originator;
    spender: spender;
    newAllowance: new_allowance
  }; event e;
  msg = let m = {
    _tag: "AllowanceCallBack";
    _recipient: _sender;
    _amount: zero;
    originator: originator;
    spender: spender;
    newAllowance: new_allowance
  } in one_msg m; send msg
end

transition Transfer(
  originator: ByStr20,
  beneficiary: ByStr20,
  amount: Uint128,
  originatorBal: Uint128,
  beneficiaryBal: Uint128
  )
  ThrowIfNotProxy;
  isNotPaused; isNotBlacklisted originator; isNotNull beneficiary; isNotBlacklisted beneficiary; isNotSender originator beneficiary;
  isSufficientFunds originatorBal amount;
  new_originator_bal = builtin sub originatorBal amount;
  new_beneficiary_bal = builtin add beneficiaryBal amount;
  e = {
    _eventname: "TransferSuccess";
    originator: originator;
    beneficiary: beneficiary;
    amount: amount
  }; event e;
  msg_to_proxy = {
    _tag: "TransferCallBack";
    _recipient: _sender;
    _amount: zero;
    originator: originator;
    beneficiary: beneficiary;
    newOriginatorBal: new_originator_bal;
    newBeneficiaryBal: new_beneficiary_bal
  };
  msg_to_originator = {
    _tag: "TransferSuccessCallBack";
    _recipient: originator;
    _amount: zero;
    beneficiary: beneficiary;
    amount: amount
  };
  msg_to_beneficiary = {
    _tag: "RecipientAcceptTransfer";
    _recipient: beneficiary;
    _amount: zero;
    originator: originator;
    amount: amount
  };
  msgs = three_msgs msg_to_proxy msg_to_originator msg_to_beneficiary;
  send msgs
end

transition TransferFrom(
  originator: ByStr20,
  spender: ByStr20,
  beneficiary: ByStr20, 
  amount: Uint128,
  originatorBal: Uint128,
  spenderAllowance: Uint128,
  beneficiaryBal: Uint128
  )
  ThrowIfNotProxy;
  isNotPaused; isNotBlacklisted originator; isNotBlacklisted spender; isNotNull beneficiary; isNotBlacklisted beneficiary; isNotSender originator beneficiary;
  isSufficientFunds originatorBal amount; isSufficientAllowance spenderAllowance amount;
  new_originator_bal = builtin sub originatorBal amount;
  new_beneficiary_bal = builtin add beneficiaryBal amount;
  new_spender_allowance = builtin sub spenderAllowance amount;
  e = {
    _eventname: "TransferFromSuccess";
    originator: originator;
    spender: spender;
    beneficiary: beneficiary;
    amount: amount
  }; event e;
  msg_to_proxy_balances = {
    _tag: "TransferFromCallBack";
    _recipient: _sender;
    _amount: zero;
    originator: originator;
    beneficiary: beneficiary;
    newOriginatorBal: new_originator_bal;
    newBeneficiaryBal: new_beneficiary_bal
  };
  msg_to_proxy_allowance = {
    _tag: "AllowanceCallBack";
    _recipient: _sender;
    _amount: zero;
    originator: originator;
    spender: spender;
    newAllowance: new_spender_allowance
  };
  msg_to_spender = {
    _tag: "TransferFromSuccessCallBack";
    _recipient: spender;
    _amount: zero;
    initiator: spender;
    sender: originator;
    recipient: beneficiary;
    amount: amount
  };
  msg_to_beneficiary = {
    _tag: "RecipientAcceptTransferFrom";
    _recipient: beneficiary;
    _amount: zero;
    initiator: spender;
    sender: originator;
    recipient: beneficiary;
    amount: amount
  };
  msgs = four_msgs msg_to_proxy_balances msg_to_proxy_allowance msg_to_spender msg_to_beneficiary;
  send msgs
end

transition UpdateZilswap(
  newAddr: ByStr20
  )
  ThrowIfNotProxy;
  zilswap := newAddr
end

procedure UpdateDeadline(
  blockDeadline: Uint128
  )
  current_block <- &BLOCKNUMBER;
  deadline = builtin badd current_block blockDeadline;
  deadline_block := deadline
end

transition SwapZILForPSTAndShare(
  minPstAmount: Uint128,
  originator: ByStr20,
  beneficiary: List ByStr20,
  blockDeadline: Uint128
  )
  ThrowIfNotProxy;
  UpdateDeadline blockDeadline;
  deadline <- deadline_block;
  zilswap_addr <- zilswap; accept;
  msg = let m = {
    _tag: "SwapExactZILForTokens";
    _recipient: zilswap_addr;
    _amount: _amount;
    token_address: proxyAddr;
    min_token_amount: minPstAmount;
    deadline_block: deadline;
    recipient_address: originator
  } in one_msg m; send msg;
  msg = let m = {
    _tag: "ProfitShareCallBack";
    _recipient: proxyAddr;
    _amount: zero;
    originator: originator;
    beneficiary: beneficiary
  } in one_msg m; send msg
end