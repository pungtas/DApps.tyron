(* v0.3.0
xPSTi.tyron: wrapped profit-sharing token Zilliqa reference contract - Implementation smart contract.
Self-Sovereign Identity Protocol.
Copyright (C) Tyron Pungtas and its affiliates.
www.ssiprotocol.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.*)

scilla_version 0

import BoolUtils IntUtils ListUtils PairUtils

library XPSTi

  type Account =
    | Account of Uint128 Uint128 Bool
    
  let one_msg = fun( msg: Message ) =>
    let nil_msg = Nil{ Message } in Cons{ Message } msg nil_msg

  let two_msgs = fun( msg1: Message ) => fun( msg2: Message ) =>
    let msgs_tmp = one_msg msg2 in Cons{ Message } msg1 msgs_tmp

  let three_msgs = fun( msg1: Message ) => fun( msg2: Message ) => fun( msg3: Message ) =>
    let msgs_tmp = two_msgs msg2 msg3 in Cons{ Message } msg1 msgs_tmp

  let four_msgs = fun( msg1: Message ) => fun( msg2: Message ) => fun( msg3: Message ) => fun( msg4: Message ) =>
    let msgs_tmp = three_msgs msg2 msg3 msg4 in Cons{ Message } msg1 msgs_tmp

  type Error =
    | CodeNotProxy
    | CodeNotAdmin
    | CodeNotPauser
    | CodeNotLister
    | CodeIsPaused
    | CodeNotPaused
    | CodeIsBlocked
    | CodeNotBlocked
    | CodeSameAddress
    | CodeIsNull
    | CodeInsufficientFunds
    | CodeInsufficientAllowance
    | CodeNotValid

  let make_error = fun( error: Error ) =>
    let result = match error with
    | CodeNotProxy               => Int32 -1
    | CodeNotAdmin               => Int32 -2
    | CodeNotPauser              => Int32 -3
    | CodeNotLister              => Int32 -4
    | CodeIsPaused               => Int32 -5
    | CodeNotPaused              => Int32 -6
    | CodeIsBlocked              => Int32 -7
    | CodeNotBlocked             => Int32 -8
    | CodeSameAddress            => Int32 -9
    | CodeIsNull                 => Int32 -10
    | CodeInsufficientFunds      => Int32 -11
    | CodeInsufficientAllowance  => Int32 -12
    | CodeNotValid               => Int32 -13
    end in { _exception: "Error"; code: result }

  let zero = Uint128 0
  let one  = Uint128 1
  let hundred = Uint128 100
  let yes = True
  let no = False
  let none_uint128 = None{ Uint128 }
  let null_address = 0x0000000000000000000000000000000000000000

  let option_value = tfun 'A => fun( default: 'A ) => fun( opt_val: Option 'A ) =>
    match opt_val with
    | Some v => v
    | None => default end
    
  let option_account = let f = @option_value Account in let noAccount = Account zero zero no in f noAccount

  let account_balance = fun( getAccount: Option Account ) =>
    let account = option_account getAccount
    in match account with
    | Account balance share vote => balance end
    
  let option_uint128_value = let f = @option_value Uint128 in f zero

  let better_subtract = fun( a: Uint128 ) => fun( b: Uint128 ) =>
    let a_ge_b = uint128_ge a b in
    match a_ge_b with
    | True => builtin sub a b
    | False => zero end

contract XPSTi(
  initAdmin: ByStr20,
  proxyAddr: ByStr20 with contract 
    field total_supply: Uint128,
    field accounts: Map ByStr20 Account,
    field allowances: Map ByStr20 ( Map ByStr20 Uint128 ) end,
  zilswapAddr: ByStr20,
  tokenAddr: ByStr20
  )
  field admin: ByStr20 = initAdmin
  field pauser: ByStr20 = initAdmin
  field zilswap: ByStr20 = zilswapAddr
  field token_addr: ByStr20 = tokenAddr
  
  field paused: Bool = False
  field lister: ByStr20 = initAdmin
  field blocked: Map ByStr20 Uint128 = Emp ByStr20 Uint128
  field deadline_block: BNum = BNum 0

procedure ThrowError( err: Error )
  e = make_error err; throw e end

procedure ThrowIfNotProxy()
  verified = builtin eq proxyAddr _sender;
  match verified with
  | True =>
  | False => err = CodeNotProxy; ThrowError err end end

procedure isAdmin()
  current_admin <- admin;
  is_admin = builtin eq current_admin _origin;
  match is_admin with
  | True =>
  | False => err = CodeNotAdmin; ThrowError err end end

procedure isPauser()
  current_pauser <- pauser;
  is_pauser = builtin eq current_pauser _origin;
  match is_pauser with
  | True  =>
  | False => err = CodeNotPauser; ThrowError err end end

procedure isPaused()
  is_paused <- paused;
  match is_paused with
  | True =>
  | False => err = CodeNotPaused; ThrowError err end end

procedure isNotPaused()
  is_paused <- paused;
  match is_paused with
  | True => err = CodeIsPaused; ThrowError err
  | False => end end

procedure isLister()
  current_lister <- lister;
  is_lister = builtin eq current_lister _origin;
  match is_lister with
  | True  =>
  | False => err = CodeNotLister; ThrowError err end end

procedure isBlocked( addr: ByStr20 )
  is_blocked <- exists blocked[addr];
  match is_blocked with
  | True =>
  | False => err = CodeNotBlocked; ThrowError err end end

procedure isNotBlocked( addr: ByStr20 )
  is_blocked <- exists blocked[addr];
  match is_blocked with
  | True => err = CodeIsBlocked; ThrowError err
  | False => end end

procedure isNotNull( addr: ByStr20 )
  is_null = builtin eq null_address addr;
  match is_null with
  | True => err = CodeIsNull; ThrowError err
  | False => end end

procedure ThowIfSameAddr(
  a: ByStr20,
  b: ByStr20
  )
  is_self = builtin eq a b;
  match is_self with
  | True => err = CodeSameAddress; ThrowError err
  | False => end end

procedure isSufficientFunds(
  funds: Uint128,
  amount: Uint128
  )
  sufficient_funds = uint128_ge funds amount;
  match sufficient_funds with
  | True =>
  | False => err = CodeInsufficientFunds; ThrowError err end end

procedure isSufficientAllowance(
  allowance: Uint128,
  amount: Uint128
  )
  sufficient_allowance = uint128_ge allowance amount;
  match sufficient_allowance with
  | True =>
  | False => err = CodeInsufficientAllowance; ThrowError err end end

transition RecipientAcceptTransfer(
  sender: ByStr20,
  recipient: ByStr20,
  amount: Uint128
  ) end

transition TransferSuccessCallBack(
  sender: ByStr20, 
  recipient: ByStr20,
  amount : Uint128
  ) end

transition RecipientAcceptTransferFrom(
  initiator: ByStr20,
  sender: ByStr20,
  recipient: ByStr20,
  amount: Uint128
  )
  is_valid_transfer_to_self =
    let self_triggered = builtin eq initiator _this_address
    in let is_transfer_to_self = builtin eq recipient _this_address
    in andb self_triggered is_transfer_to_self;
  match is_valid_transfer_to_self with
  | False => err = CodeNotValid; ThrowError err
  | True => end end

transition TransferFromSuccessCallBack(
  initiator: ByStr20,
  sender: ByStr20,
  recipient: ByStr20,
  amount: Uint128
  ) end

transition UpdateAdmin( newAdmin: ByStr20 )
  isAdmin; isNotPaused; isNotNull newAdmin;
  current_admin <- admin;
  ThowIfSameAddr current_admin newAdmin; admin := newAdmin;
  e = { _eventname: "AdminUpdated";
    admin_updated: newAdmin
  }; event e end

transition UpdatePauser( newPauser: ByStr20 )
  isAdmin; isNotPaused; isNotNull newPauser;
  current_pauser <- pauser;
  ThowIfSameAddr current_pauser newPauser; pauser := newPauser;
  e = { _eventname: "PauserUpdated";
    pauser_updated: newPauser
  }; event e end

transition Pause()
  ThrowIfNotProxy; isPauser;
  isNotPaused; paused := yes;
  e = { _eventname: "SmartContractPaused";
    pauser: _origin
  }; event e end

transition Unpause()
  ThrowIfNotProxy; isPauser;
  isPaused; paused := no;
  e = { _eventname: "SmartContractUnpaused";
    pauser: _origin
  }; event e end

transition UpdateLister( newLister: ByStr20 )
  isAdmin; isNotPaused; isNotNull newLister;
  current_lister <- lister;
  ThowIfSameAddr current_lister newLister; lister:= newLister;
  e = { _eventname: "ListerUpdated";
    lister_updated: newLister
  }; event e end

transition Block( addr: ByStr20 )
  ThrowIfNotProxy; isLister;
  isNotPaused; isNotNull addr; isNotBlocked addr; blocked[addr] := one;
  e = { _eventname: "AddressBlocked";
    address: addr;
    lister: _origin
  }; event e end

transition Unblock( addr: ByStr20 )
  ThrowIfNotProxy; isLister;
  isNotPaused; isNotNull addr; isBlocked addr; delete blocked[addr];
  e = { _eventname: "AddressUnblocked";
    address: addr;
    lister: _origin
  }; event e end

transition Mint(
  originator: ByStr20,
  beneficiary: ByStr20, (* self-triggered, i.e. the originator is the beneficiary *)
  amount: Uint128
  )
  ThrowIfNotProxy; isNotPaused;
  isNotBlocked originator;
  current_supply <-& proxyAddr.total_supply;
  new_supply = builtin add current_supply amount;
  get_account <-& proxyAddr.accounts[originator]; bal = account_balance get_account;
  new_bal = builtin add bal amount;
  token_address <- token_addr;
  msg_to_token = { _tag: "TransferFrom"; _recipient: token_address; _amount: zero;
    from: originator;
    to: _this_address;
    amount: amount
  };
  msg_to_proxy = { _tag: "MintCallBack"; _recipient: _sender; _amount: zero;
    beneficiary: originator;
    newBalance: new_bal;
    newSupply: new_supply
  };
  msg_to_originator = { _tag: "RecipientAcceptMint"; _recipient: originator; _amount: zero;
    minter: originator;
    amount: amount
  };
  msgs = three_msgs msg_to_token msg_to_proxy msg_to_originator; send msgs end

transition Burn(
  originator: ByStr20,
  amount: Uint128
  )
  ThrowIfNotProxy; isNotPaused;
  isNotBlocked originator;
  get_account <-& proxyAddr.accounts[originator]; bal = account_balance get_account;
  isSufficientFunds bal amount;
  new_balance = builtin sub bal amount;
  current_supply <-& proxyAddr.total_supply;
  new_supply = builtin sub current_supply amount;
  e = { _eventname: "XBurnt";
    originator: originator;
    amount: amount
  }; event e;
  token_address <- token_addr;
  msg_to_token = { _tag: "Transfer"; _recipient: token_address; _amount: zero;
    to: originator;
    amount: amount
  };
  msg_to_proxy = { _tag: "BurnCallBack"; _recipient: _sender; _amount: zero;
    originator: originator;
    newBalance: new_balance;
    newSupply: new_supply
  };
  msg_to_originator = {  _tag: "BurnSuccessCallBack"; _recipient: originator; _amount: zero;
    amount: amount
  };
  msgs = three_msgs msg_to_token msg_to_proxy msg_to_originator; send msgs end

transition LawEnforcementWipingBurn( addr: ByStr20 )
  ThrowIfNotProxy; isLister;
  isNotPaused; isBlocked addr; isNotBlocked _origin;
  get_account <-& proxyAddr.accounts[addr]; bal = account_balance get_account;
  current_supply <-& proxyAddr.total_supply;
  new_supply = builtin sub current_supply bal;
  e = { _eventname: "LawEnforcementWipingBurnt";
    lister: _origin;
    address: addr;
    amount: bal
  }; event e;
  msg_to_proxy = { _tag: "LawEnforcementWipingBurnCallBack";
    _recipient: _sender;
    _amount: zero;
    addr: addr;
    newSupply : new_supply
  };
  msg_to_lister = { _tag: "LawEnforcementWipingBurnSuccessCallBack";
    _recipient: _origin;
    _amount: zero;
    addr: addr;
    amount: bal
  }; msgs = two_msgs msg_to_proxy msg_to_lister; send msgs end

transition Transfer(
  originator: ByStr20,
  beneficiary: ByStr20,
  amount: Uint128
  )
  ThrowIfNotProxy;
  isNotPaused; isNotBlocked originator; isNotNull beneficiary; isNotBlocked beneficiary; ThowIfSameAddr originator beneficiary;
  get_originator_account <-& proxyAddr.accounts[originator]; originator_bal = account_balance get_originator_account;
  isSufficientFunds originator_bal amount;
  new_originator_bal = builtin sub originator_bal amount;
  get_beneficiary_account <-& proxyAddr.accounts[beneficiary]; beneficiary_bal = account_balance get_beneficiary_account;
  new_beneficiary_bal = builtin add beneficiary_bal amount;
  e = { _eventname: "TransferSuccess";
    originator: originator;
    beneficiary: beneficiary;
    amount: amount
  }; event e;
  msg_to_proxy = {
    _tag: "TransferCallBack";
    _recipient: _sender;
    _amount: zero;
    originator: originator;
    beneficiary: beneficiary;
    newOriginatorBal: new_originator_bal;
    newBeneficiaryBal: new_beneficiary_bal
  };
  msg_to_originator = { _tag: "TransferSuccessCallBack";
    _recipient: originator;
    _amount: zero;
    sender: originator;
    recipient: beneficiary;
    amount: amount
  };
  msg_to_beneficiary = { _tag: "RecipientAcceptTransfer";
    _recipient: beneficiary;
    _amount: zero;
    sender: originator;
    recipient: beneficiary;
    amount: amount
  }; msgs = three_msgs msg_to_proxy msg_to_originator msg_to_beneficiary; send msgs end

transition IncreaseAllowance(
  originator: ByStr20,
  spender: ByStr20,
  amount: Uint128
  )
  ThrowIfNotProxy; isNotPaused; 
  isNotBlocked originator; isNotBlocked spender; ThowIfSameAddr originator spender;
  get_allowance <-& proxyAddr.allowances[originator][spender]; allowance = option_uint128_value get_allowance;
  new_allowance = builtin add allowance amount;
  e = { _eventname: "AllowanceIncreased";
    originator: originator;
    spender: spender;
    allowance_updated: new_allowance
  }; event e;
  msg = let m = { _tag: "AllowanceCallBack";
    _recipient: _sender;
    _amount: zero;
    originator: originator;
    spender: spender;
    newAllowance: new_allowance
  } in one_msg m; send msg end

transition DecreaseAllowance(
  originator: ByStr20,
  spender: ByStr20,
  amount: Uint128
  )
  ThrowIfNotProxy; isNotPaused;
  isNotBlocked originator; isNotBlocked spender; ThowIfSameAddr originator spender;
  get_allowance <-& proxyAddr.allowances[originator][spender]; allowance = option_uint128_value get_allowance;
  new_allowance = better_subtract allowance amount;
  e = { _eventname: "AllowanceDecreased";
    originator: originator;
    spender: spender;
    allowance_updated: new_allowance
  }; event e;
  msg = let m = { _tag: "AllowanceCallBack";
    _recipient: _sender;
    _amount: zero;
    originator: originator;
    spender: spender;
    newAllowance: new_allowance
  } in one_msg m; send msg end

transition TransferFrom(
  originator: ByStr20,
  spender: ByStr20,
  beneficiary: ByStr20, 
  amount: Uint128
  )
  ThrowIfNotProxy; isNotPaused; 
  isNotBlocked originator; isNotBlocked spender; isNotBlocked beneficiary; isNotNull beneficiary; ThowIfSameAddr originator beneficiary;
  get_originator_account <-& proxyAddr.accounts[originator]; originator_bal = account_balance get_originator_account;
  isSufficientFunds originator_bal amount;
  get_allowance <-& proxyAddr.allowances[originator][spender]; allowance = option_uint128_value get_allowance;
  isSufficientAllowance allowance amount;
  new_originator_bal = builtin sub originator_bal amount;
  new_allowance = builtin sub allowance amount;
  get_beneficiary_account <-& proxyAddr.accounts[beneficiary]; beneficiary_bal = account_balance get_beneficiary_account;
  new_beneficiary_bal = builtin add beneficiary_bal amount;
  e = { _eventname: "TransferFromSuccess";
    originator: originator;
    spender: spender;
    beneficiary: beneficiary;
    amount: amount
  }; event e;
  msg_to_proxy_balances = { _tag: "TransferFromCallBack";
    _recipient: _sender;
    _amount: zero;
    originator: originator;
    beneficiary: beneficiary;
    newOriginatorBal: new_originator_bal;
    newBeneficiaryBal: new_beneficiary_bal
  };
  msg_to_proxy_allowance = { _tag: "AllowanceCallBack";
    _recipient: _sender;
    _amount: zero;
    originator: originator;
    spender: spender;
    newAllowance: new_allowance
  };
  msg_to_spender = { _tag: "TransferFromSuccessCallBack";
    _recipient: spender;
    _amount: zero;
    initiator: spender;
    sender: originator;
    recipient: beneficiary;
    amount: amount
  };
  msg_to_beneficiary = { _tag: "RecipientAcceptTransferFrom";
    _recipient: beneficiary;
    _amount: zero;
    initiator: spender;
    sender: originator;
    recipient: beneficiary;
    amount: amount
  }; msgs = four_msgs msg_to_proxy_balances msg_to_proxy_allowance msg_to_spender msg_to_beneficiary; send msgs end

transition UpdateZilswap( newAddr: ByStr20 )
  isAdmin; zilswap := newAddr end

transition UpdateTokenAddr( newAddr: ByStr20 )
  isAdmin; token_addr := newAddr end

procedure UpdateDeadline( blockDeadline: Uint128 )
  current_block <- &BLOCKNUMBER;
  deadline = builtin badd current_block blockDeadline;
  deadline_block := deadline end

transition SwapZILForPSTAndDistribute(
  pstAmount: Uint128,
  originator: ByStr20,
  beneficiary: Option( List ByStr20 ),
  blockDeadline: Uint128
  )
  ThrowIfNotProxy;
  UpdateDeadline blockDeadline; deadline <- deadline_block;
  zilswap_addr <- zilswap; token_address <- token_addr;
  accept; msg = let m = { _tag: "SwapZILForExactTokens"; _recipient: zilswap_addr; _amount: _amount;
    token_address: token_address;
    token_amount: pstAmount;
    deadline_block: deadline;
    recipient_address: _this_address
  } in one_msg m; send msg;
  get_originator_account <-& proxyAddr.accounts[originator]; originator_bal = account_balance get_originator_account;
  new_originator_bal = builtin add originator_bal pstAmount;
  current_supply <-& proxyAddr.total_supply;
  new_supply = builtin add pstAmount current_supply;
  msg = let m = { _tag: "MintCallBack"; _recipient: proxyAddr; _amount: zero;
    beneficiary: originator;
    newBeneficiaryBal: new_originator_bal;
    newSupply: new_supply
  } in one_msg m; send msg;
  msg = let m = { _tag: "SwapZILForPSTAndDistributeCallBack"; _recipient: proxyAddr; _amount: zero;
    originator: originator;
    beneficiary: beneficiary
  } in one_msg m; send msg end