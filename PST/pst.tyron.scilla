(*
  INIT.tyron: SSI initialization & DNS smart contract.
  Self-Sovereign Identity Protocol.
  Copyright (C) Tyron Pungtas and its affiliates.

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
*)

scilla_version 0

import PairUtils

library INIT

  let one_msg = fun( msg: Message ) =>
    let nil_msg = Nil{ Message } in Cons{ Message } msg nil_msg

  let two_msgs = fun( msg1: Message ) => fun( msg2: Message ) =>
    let msgs_tmp = one_msg msg2 in Cons{ Message } msg1 msgs_tmp

  type Error =
    | CodeDomainTaken
    | CodeWrongCaller
    | CodeInsufficientFunds
    | CodeNotProxy
    | CodeNotValid

  let make_error = fun( error: Error ) =>
    let result = match error with
    | CodeDomainTaken            => Int32 -1
    | CodeWrongCaller            => Int32 -4
    | CodeInsufficientFunds      => Int32 -2
    | CodeNotProxy               => Int32 -3
    | CodeNotValid               => Int32 -5
    end in { _exception: "Error"; code: result }
  
  let zero = Uint128 0
  
  type Code =
    | Code of String ( Pair Uint128 String )

  let ten_zil = Uint128 10000000000000
  let ten = Uint128 10
  let hundred = Uint128 100

contract INIT(
  initAdmin: ByStr20
  )
  field admin: ByStr20 = initAdmin
  field treasury: ByStr20 = initAdmin

  (* Tyron smart contracts' code by version
  @key: domain (e.g. "ssi", "did", "agent", "mapu")
  @value: map of
    @key: version
    @value: hex-encoded code *)
  field tyron_code: Map String ( Map Uint128 String ) = Emp String ( Map Uint128 String )
  
  (* DNS records
  @key: domain (e.g. "ssi", "did", "agent", "mapu", "tyron")
  @value: map of
    @key: username
    @value: address *)
  field dns: Map String ( Map String ByStr20 ) = Emp String ( Map String ByStr20 )

  (* DNS fees
  @key: domain (e.g. "ssi", "did", "agent", "mapu", "tyron")
  @value: pair of purchase fee (in $ZIL) and transfer fee (as a percentage of transfer price) *)
  field domain_fee: Map String Pair Uint128 Uint128 = Emp String Pair Uint128 Uint128
  
  (* Dapp records
  @key: implementation address
  @value: proxy address *)
  field records: Map ByStr20 ByStr20 = Emp ByStr20 ByStr20
  (* upgrade record to did service *)
  
  (* Implementation records
  @key: proxy address
  @value: implementation address *)
  field implementations: Map ByStr20 ByStr20 = Emp ByStr20 ByStr20
  
procedure ThrowError( err: Error )
  e = make_error err; throw e
end

procedure VerifyCaller( addr: ByStr20 )
  is_correct = builtin eq addr _sender;
  match is_correct with
  | True =>
  | False => err = CodeWrongCaller; ThrowError err
  end
end

transition UpdateAdmin( newAdmin: ByStr20 )
  current_admin <- admin; VerifyCaller current_admin;
  admin := newAdmin
end

transition UpdateTreasuryAddr( newAddr: ByStr20 )
  current_admin <- admin; VerifyCaller current_admin;
  treasury := newAddr;
  e = {
    _eventname: "TreasuryAddressUpdated";
    newAddress: newAddr
  }; event e
end
  
(* Publish .tyron code *)
transition SetCode( tyron: Code )
  current_admin <- admin; VerifyCaller current_admin;
  match tyron with
  | Code domain version_code  =>
      version = let fst_element = @fst Uint128 String in fst_element version_code;
      code = let snd_element = @snd Uint128 String in snd_element version_code;
      tyron_code[domain][version] := code;
      e = {
        _eventname: "TyronCodeUpdated";
        domain: domain;
        version: version;
        code: code
      }; event e
  end
end

transition UpdateDomainFee(
  domain: String,
  fee: Pair Uint128 Uint128
)
  current_admin <- admin; VerifyCaller current_admin;
  domain_fee[domain] := fee
end

transition BuyDomainNameNFT( userDomain: Pair String String )
  username = let fst_element = @fst String String in fst_element userDomain;
  domain = let snd_element = @snd String String in snd_element userDomain;
  taken <- exists dns[domain][username];
  match taken with
  | True => err= CodeDomainTaken; ThrowError err
  | False => 
      get_fee <- domain_fee[domain];
      match get_fee with
      | None => err = CodeNotValid; ThrowError err
      | Some fee =>
          p_fee = let fst_element = @fst Uint128 Uint128 in fst_element fee;
          is_enough = builtin lt p_fee _amount;
          match is_enough with
          | True =>
              accept;
              refund = builtin sub _amount p_fee;
              is_zero_refund = builtin eq refund zero;
              match is_zero_refund with
              | True =>
              | False =>
                msg = let m = {
                  _tag: "AddFunds";
                  _recipient: _sender;
                  _amount: refund
                } in one_msg m; send msg
              end;
              dns[domain][username] := _sender
          | False => err = CodeInsufficientFunds; ThrowError err
          end
      end
  end
end

transition TransferDomainNameNFT( userDomain: Pair String String )
  username = let fst_element = @fst String String in fst_element userDomain;
  domain = let snd_element = @snd String String in snd_element userDomain;
  get_owner <- dns[domain][username];
  match get_owner with
  | Some owner =>
      is_sender = builtin eq owner _sender;
      match is_sender with
      | False => err = CodeWrongCaller; ThrowError err
      | True =>
          is_zero = builtin eq _amount zero;
          match is_zero with
          | True => err = CodeNotValid; ThrowError err
          | False =>
              get_fee <- domain_fee[domain];
              match get_fee with
              | None => err = CodeNotValid; ThrowError err
              | Some fee =>
                  t_fee = let snd_element = @snd Uint128 Uint128 in snd_element fee;
                  psc_fee = let percent = builtin div _amount hundred in builtin mul t_fee percent;
                  current_treasury <- treasury;
                  (* upgrade to verify that the data got signed by the beneficiary's DID*)
                  accept; msg_to_psc = {
                      _tag: "AddFunds"; _recipient: current_treasury; _amount: psc_fee
                  };
                  payment = builtin sub _amount psc_fee;
                  msg_to_owner = {
                    _tag: "AddFunds";
                    _recipient: owner;
                    _amount: payment
                  };
                  msgs = two_msgs msg_to_psc msg_to_owner; send msgs;
                  dns[domain][username] := _sender (* upgrade *)
              end
          end  
      end
  | None => err= CodeNotValid; ThrowError err
  end
end

(* Sets proxy and implementation addresses of a token *)
transition SetRecord(
  proxyAddr: ByStr20,
  implAddr: ByStr20
  )
  current_admin <- admin; VerifyCaller current_admin;
  records[implAddr] := proxyAddr;
  e = {
    _eventname: "RecordUpdated";
    proxyAddress: proxyAddr;
    implementationAddress: implAddr
  }; event e
end
