(*
INIT.tyron: SSI initialization & DNS smart contract.
Tyron Self-Sovereign Identity Protocol.
Copyright (C) Tyron Pungtas and its affiliates.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*)

scilla_version 0

library INIT

let one_msg = fun( msg: Message ) =>
  let nil_msg = Nil{ Message } in Cons{ Message } msg nil_msg

let two_msgs = fun( msg1: Message ) => fun( msg2: Message ) =>
  let msgs_tmp = one_msg msg2 in Cons{ Message } msg1 msgs_tmp

let zero = Uint128 0

type Error =
  | CodeDomainTaken
  | CodeNotValid
  | CodeNotRightCaller

let make_error = fun( error: Error ) =>
  let result = match error with
  | CodeDomainTaken            => Int32 -1
  | CodeNotValid               => Int32 -1
  | CodeNotRightCaller         => Int32 -3
  end in { _exception: "Error"; code: result }
  
let option_value = tfun 'A => fun( default: 'A ) => fun( opt_val: Option 'A ) =>
  match opt_val with
  | Some v => v
  | None => default
  end
  
let option_uint128_value = let f = @option_value Uint128 in f zero

contract INIT(
  initAdmin: ByStr20
  )
  field admin: ByStr20 = initAdmin

  (* DID-Smart-Contract code by version
  @key: version
  @value: hex-encoded code *)
  field did_code: Map String String = Emp String String
  
(* DNS records
  @key: SsiDomain (e.g. ".did", ".agent", ".mapu")
  @value: Map of
    @key: domain name
    @value: address *)
  field dns: Map String (Map String ByStr20) = Emp String (Map String ByStr20)

(* Resource records
  @key: token 
  @value: proxy address *)
  field records: Map String ByStr20 = Emp String ByStr20
  
(* Token implementations
  @key: proxy address
  @value: implementation address *)
  field implementations: Map ByStr20 ByStr20 = Emp ByStr20 ByStr20

procedure ThrowError(
  err: Error
  )
  e = make_error err; throw e
end

(* Validate address against _sender *)
procedure Calling(
  check: ByStr20
)
  is_correct = builtin eq check _sender;
  match is_correct with
  | True =>
  | False => err= CodeNotRightCaller; ThrowError err
  end
end

(* Update the admin's address *)
transition UpdateAdmin(
  newAdmin: ByStr20
)
  admin_addr <- admin; Calling admin_addr;
  admin := newAdmin
end
  
(* Set the DID-Smart-Contract code *)
transition SetDidCode(
  version: String,
  code: String
  )
  admin_addr <- admin; Calling admin_addr;
  did_code[version] := code;
  e = {
    _eventname: "Updated_DID_code";
    version: version;
    code: code
  }; event e
end

(* Set a domain name in the DNS *)
transition SetDomain(
  domain: String,
  username: String,
  agent: String
  )
  taken <- exists dns[domain][username];
  match taken with
  | True =>
      err = CodeDomainTaken; ThrowError err
  | False =>
      dns[domain][username] := _sender
  end
end

(* Sets the token name, proxy address and implementation address of a token *)
transition SetRecord(
  token: String,
  proxyAddr: ByStr20,
  implementationAddr: ByStr20
  )
  admin_addr <- admin; Calling admin_addr;
  records[token] := proxyAddr;
  implementations[proxyAddr] := implementationAddr;
  e = {
    _eventname: "Updated_Token";
    token: token;
    proxy_address: proxyAddr;
    implementation_address: implementationAddr
  }; event e
end

(* Called by a Self-Sovereign Identity to verify token addresses *)
transition Verify(
  token: String
  )
  proxy_addr <- records[token];
  match proxy_addr with
  | Some addr =>
      implementation_addr <- implementations[addr];
      match implementation_addr with
      | Some implementation =>
          msg = let m = {
            _tag: "VerifyCallBack";
            _recipient: _sender;
            _amount: zero;
            token: token;
            proxy: addr;
            implementation: implementation
          } in one_msg m; send msg
      | None => err= CodeNotValid; ThrowError err
      end
  | None => err= CodeNotValid; ThrowError err
  end
end