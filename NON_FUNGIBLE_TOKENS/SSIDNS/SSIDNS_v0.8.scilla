(* «dns.ssi» DApp v0.8
Domain Name System that incorporates the ZRC6 NFT standard (which has an MIT SPDX-License-Identifier)
Tyron SSI: Self-Sovereign Identity Protocol
Copyright Tyron Mapu Community Interest Company 2023. All rights reserved.
You acknowledge and agree that Tyron Mapu Community Interest Company (Tyron) own all legal right, title and interest in and to the work, software, application, source code, documentation and any other documents in this repository (collectively, the Program), including any intellectual property rights which subsist in the Program (whether those rights happen to be registered or not, and wherever in the world those rights may exist), whether in source code or any other form.
Subject to the limited license below, you may not (and you may not permit anyone else to) distribute, publish, copy, modify, merge, combine with another program, create derivative works of, reverse engineer, decompile or otherwise attempt to extract the source code of, the Program or any part thereof, except that you may contribute to this repository.
You are granted a non-exclusive, non-transferable, non-sublicensable license to distribute, publish, copy, modify, merge, combine with another program or create derivative works of the Program (such resulting program, collectively, the Resulting Program) solely for Non-Commercial Use as long as you:
1. give prominent notice (Notice) with each copy of the Resulting Program that the Program is used in the Resulting Program and that the Program is the copyright of Tyron; and
2. subject the Resulting Program and any distribution, publication, copy, modification, merger therewith, combination with another program or derivative works thereof to the same Notice requirement and Non-Commercial Use restriction set forth herein.
Non-Commercial Use means each use as described in clauses (1)-(3) below, as reasonably determined by Tyron in its sole discretion:
1. personal use for research, personal study, private entertainment, hobby projects or amateur pursuits, in each case without any anticipated commercial application;
2. use by any charitable organization, educational institution, public research organization, public safety or health organization, environmental protection organization or government institution; or
3. the number of monthly active users of the Resulting Program across all versions thereof and platforms globally do not exceed 10,000 at any time.
You will not use any trade mark, service mark, trade name, logo of Tyron or any other company or organization in a way that is likely or intended to cause confusion about the owner or authorized user of such marks, names or logos.
If you have any questions, comments or interest in pursuing any other use cases, please reach out to us at tyron@ssiprotocol.com.*)

scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)

import BoolUtils ListUtils IntUtils PairUtils
library NonfungibleToken

type Operation =
| Add
| Sub

(* Global variables *)
let zero_address = 0x0000000000000000000000000000000000000000
let zero_hash = 0x0000000000000000000000000000000000000000000000000000000000000000
let false = False
let true = True
let zero_128 = Uint128 0
let zero = Uint256 0
let one = Uint256 1
let empty_string = ""
let zilID = "zil"

let add_operation = Add
let sub_operation = Sub
let min_fee_bps = Uint128 1
let max_fee_bps = Uint128 10000

(* Library functions *)
let one_msg = 
  fun (msg: Message) => 
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1: Message) =>
  fun (msg2: Message) =>
    let msgs_tmp = one_msg msg2 in
    Cons {Message} msg1 msgs_tmp

let get_bal =
  fun (maybe_bal: Option Uint256) =>
    match maybe_bal with
    | None => zero
    | Some bal => bal
    end

(* Error exception *)
type Error =
  | CodeWrongStatus
  | CodeIsNull
  | CodeDomainTaken
  | CodeInvalidInput
  | CodeWrongSender
  | CodeDidIsNull
  | CodeSameValue
  | CodeIsInsufficient

let make_error = fun (error: Error) => fun (version: String) => fun (code: Int32) =>
    let exception = match error with
    | CodeWrongStatus             => "CodeWrongStatus"
    | CodeIsNull                  => "CodeIsNull"
    | CodeDomainTaken             => "CodeDomainTaken"
    | CodeInvalidInput            => "CodeInvalidInput"
    | CodeWrongSender             => "CodeWrongSender"
    | CodeDidIsNull               => "CodeDidIsNull"
    | CodeSameValue               => "CodeSameValue"
    | CodeIsInsufficient          => "InsufficientAmount"
    end in { _exception: exception; contractVersion: version; errorCode: code }

  let option_value = tfun 'A => fun( default: 'A ) => fun( input: Option 'A) =>
    match input with
    | Some v => v
    | None => default end
  let option_bystr20_value = let f = @option_value ByStr20 in f zero_address
  let option_bystr32_value = let f = @option_value ByStr32 in f zero_hash
  
(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract NonfungibleToken(
  initial_contract_owner: ByStr20,
  (* @dev: Initial Base URI, e.g. 'https://creatures-api.zilliqa.com/api/creature/'. *)
  initial_base_uri: String,
  name: String,
  symbol: String,
  (* Previous DNS records. *)
  init_dns: Map ByStr32 ByStr20,
  (* Initial .did NFT Domain Name of the contract owner. *)
  init_nft: ByStr32,
  (* SSI INIT DApp *)
  init: ByStr20 with contract field dApp: ByStr20 with contract
    field implementation: ByStr20 with contract
      field utility: Map String Map String Uint128 end,
    field did_dns: Map String ByStr20 with contract
      field controller: ByStr20,
      field services: Map String ByStr20 end end end
  )
  with (* Contract constraints *)
    (* 'initial_contract_owner' must not be the zero address *)
    let is_contract_owner_invalid = builtin eq initial_contract_owner zero_address in 
    (* 'init_nft' must not be the zero ByStr32 *)
    let is_nft_invalid = builtin eq init_nft zero_hash in 
    let is_owner_or_nft_invalid = orb is_contract_owner_invalid is_nft_invalid in
    (* 'name' must not be an empty string *)
    let is_name_invalid = builtin eq name empty_string in
    (* 'symbol' must not be an empty string *)
    let is_symbol_invalid = builtin eq symbol empty_string in
    (* Check if any parameter is invalid *)
    let is_name_or_symbol_invalid = orb is_name_invalid is_symbol_invalid in

    let is_invalid = orb is_contract_owner_invalid is_name_or_symbol_invalid in
    negb is_invalid
  =>

(***************************************************)
(*               Mutable parameters                *)
(***************************************************)

(* Emergency stop mechanism. Defaults to False. *)
field is_paused: Bool = false

(* Whether the migration from the previous DNS records is paused or not.
   @field is_paused_migration: Defaults to False. *)
field is_paused_migration: Bool = false

(* Non-Fungible Token name.
   @field token_name: Defaults to 'name'.
    No need to mutate this field since it is for remote fetch to retrieve this immutable parameter. *)
field token_name: String = name

(* Fungible Token symbol.
   @field token_symbol: Defaults to 'symbol'.
    No need to mutate this field since it is for remote fetch to retrieve this immutable parameter.*)
field token_symbol: String = symbol

(* Contract owner.
     @field nft_domain:
     Contract owner's .did domain.
     @field pending_domain:
     New owner's .did domain for ownership transfer. *)
field nft_domain: ByStr32 = init_nft
field pending_domain: ByStr32 = zero_hash

(* @optional: With the SSI DNS, the contract owner has Social Recovery available.
   @field contract_owner:
    Defaults to 'initial_contract_owner'.
   @field contract_ownership_recipient:
    Defaults to the 'zero_address'.
field contract_owner: ByStr20 = initial_contract_owner
field contract_ownership_recipient: ByStr20 = zero_address *)

(* Recipient address for the royalties.
   @field royalty_recipient: Defaults to 'initial_contract_owner'. *)
field royalty_recipient: ByStr20 = initial_contract_owner

(* Royalty fee BPS, e.g. 1 = 0.01%, 10000 = 100%.
   @field royalty_fee_bps: Defaults to 1000 (1%). *)
field royalty_fee_bps: Uint128 = Uint128 1000

(* Base URI.
   @field base_uri: Defaults to 'initial_base_uri'. *)
field base_uri: String = initial_base_uri

(* NFT data per token ID.
   @field token_uris.
   @field token_domains.
   @field token_owners:
      @param (Uint256) token_id: An unsigned integer type of 256 bits.
      @param (String) uri: A string representing a Uniform Resource Identifier.
      @param (ByStr32) domain_id: A 32-byte string.
      @param (ByStr20) owner_addr: A 20-byte string representing the token holder address. *)
field token_uris: Map Uint256 String = Emp Uint256 String
field token_domains: Map Uint256 ByStr32 = Emp Uint256 ByStr32
field token_owners: Map Uint256 ByStr20 = Emp Uint256 ByStr20

(* NFT data per domain name.
   @field nft_dns:
    NFT Domain Name System (with the Resolved Address).
    Defaults to the previous DNS records (they need to get activated during migration).
   @field nft_domain_names:
    Registry for settled domains.
    Reverse resolution to fetch token ID per domain.
      @param (ByStr32) domain_id: A 32-byte string.
      @param (ByStr20) resolved_addr: A 20-byte string representing the Resolution address.
        It can be different than the owner's address.
      @param (Uint256) token_id: An unsigned integer type of 256 bits. *)
field nft_dns: Map ByStr32 ByStr20 = init_dns
field nft_domain_names: Map ByStr32 Uint256 = Emp ByStr32 Uint256

(* Token stats.
   @field token_id_count:
    Total number of tokens minted (to ensure unique token IDs).
    Represents the number of tokens that have ever existed.
   @field total_supply:
    Current number of tokens in existence.
     @param (Uint256) id: An unsigned integer type of 256 bits. *)
field token_id_count: Uint256 = Uint256 0
field total_supply: Uint256 = Uint256 0

(* @dev: Amount of tokens owned per address.
   @field balances: Mapping from token owner to the number of tokens owned. *)
field balances: Map ByStr20 Uint256 = Emp ByStr20 Uint256

(* @optional: With the SSI DNS, every user can mint their own tokens without intermediaries.
   @field minters:
    Addresses allowed to mint new tokens.
    The 'initial_contract_owner' is a minter by default.
field minters: Map ByStr20 Bool =
  let emp_map = Emp ByStr20 Bool in
  builtin put emp_map initial_contract_owner true *)

(* A spender is an address authorised to transfer tokens instead of the token owner.
   @field spenders: Mapping from token ID to a spender. *)
field spenders: Map Uint256 ByStr20 = Emp Uint256 ByStr20

(* Address authorised by the token owner to have the same capabilities as the owner.
   @field operators: Mapping from token owner to their operators. *)
field operators: Map ByStr20 (Map ByStr20 Bool) = Emp ByStr20 (Map ByStr20 Bool)

(* Smart contract @version *)
field version: String = "SSIDNS_0.8.0"

(***************************************************)
(*               Contract procedures               *)
(***************************************************)

(* Emits an error & cancels the transaction.
     @param err: The Error data type.
     @param code: A signed integer type of 32 bits. *)
procedure ThrowError(err: Error, code: Int32)
  ver <- version; e = make_error err ver code; throw e
end

(* Verifies that the contract is active (unpaused). *) 
procedure RequireNotPaused()
  paused <- is_paused; match paused with
    | False => | True => err = CodeWrongStatus; code = Int32 -1; ThrowError err code end
end

(* Verifies that the hash is not null.
     @param input: A 32-byte string. *) 
procedure ThrowIfNullHash(input: ByStr32)
  is_null = builtin eq input zero_hash; match is_null with
    | False => | True => err = CodeIsNull; code = Int32 -2; ThrowError err code end
end

(* Verifies that the domain name is not in the NFT DNS.
   Thus it is fully available for minting.
     @param domain_id: A 32-byte string. *) 
procedure RequireNotTaken(domain_id: ByStr32)
  ThrowIfNullHash domain_id;
  is_taken <- exists nft_dns[domain_id]; match is_taken with
    | False => | True =>
      err = CodeDomainTaken; code = Int32 -3; ThrowError err code end
end

(* Verifies that the domain name does not have a valid owner.
   The NFT DNS during migration does not ensure a valid owner.
     @param domain_id: A 32-byte string. *) 
procedure RequireNotRegistered(domain_id: ByStr32)
  ThrowIfNullHash domain_id;
  is_registered <- exists nft_domain_names[domain_id]; match is_registered with
    | False => | True => err = CodeDomainTaken; code = Int32 -4; ThrowError err code end
end

procedure RequireValidRoyaltyFee(fee_bps: Uint128)
  is_gte_min = uint128_ge fee_bps min_fee_bps;
  is_lte_max = uint128_le fee_bps max_fee_bps;
  
  is_valid = andb is_gte_min is_lte_max; match is_valid with 
    | True => | False => err = CodeInvalidInput; code = Int32 -5; ThrowError err code end
end

(* Verifies the origin of the call.
   It must match the input address.
     @param addr: A 20-byte string. *) 
procedure VerifyOrigin(addr: ByStr20)
  verified = builtin eq _origin addr; match verified with
    | True => | False => err = CodeWrongSender; code = Int32 -6; ThrowError err code end
end

(* Verifies that the transaction comes from the contract owner. *) 
procedure RequireContractOwner()
  ssi_init <-& init.dApp;
  id <- nft_domain; domain = builtin to_string id;
  get_did <-& ssi_init.did_dns[domain]; match get_did with
  | None => err = CodeDidIsNull; code = Int32 -7; ThrowError err code
  | Some did_ =>
      controller <-& did_.controller; VerifyOrigin controller end
end

(* Verifies that the given addresses are not equal.
     @params address_a & address_b: 20-byte strings. *) 
procedure RequireNotSelf(address_a: ByStr20, address_b: ByStr20)
  is_self = builtin eq address_a address_b; match is_self with
  | False => | True => err = CodeSameValue; code = Int32 -8; ThrowError err code end
end

(* @review *)
procedure RequireValidDestination(to: ByStr20)
  (* Reference: https://github.com/ConsenSys/smart-contract-best-practices/blob/master/docs/tokens.md *)
  is_zero_address = builtin eq to zero_address; match is_zero_address with
    | False => | True => err = CodeIsNull; code = Int32 -9; ThrowError err code end;

  is_this_address = builtin eq to _this_address; match is_this_address with
    | False => | True => err = CodeSameValue; code = Int32 -10; ThrowError err code
  end
end

procedure RequireOwnerOrOperator(address: ByStr20)
  is_owner = builtin eq _sender address;
  has_operator <- exists operators[address][_sender];
  is_allowed = orb is_owner has_operator; match is_allowed with
    | True => | False => err = CodeWrongSender; code = Int32 -11; ThrowError err code end
end

procedure RequireAccessToTransfer(token_owner: ByStr20, token_id: Uint256)  
  (* check if _sender is token owner *)
  is_token_owner = builtin eq token_owner _sender;
  
  (* check if _sender is spender *)
  maybe_spender <- spenders[token_id];
  is_spender = match maybe_spender with
    | None => False
    | Some spender => 
      builtin eq spender _sender end;

  (* check if _sender is operator *)
  is_operator <- exists operators[token_owner][_sender];
  
  is_spender_or_operator = orb is_spender is_operator;
  is_allowed = orb is_spender_or_operator is_token_owner; match is_allowed with
    | True => | False => err = CodeWrongSender; code = Int32 -12; ThrowError err code end
end

procedure UpdateBalance(operation: Operation, address: ByStr20)
  match operation with
  | Add =>
    maybe_count <- balances[address];
    new_count = 
      let cur_count = get_bal maybe_count in
      builtin add cur_count one; (* If overflow occurs, it throws CALL_CONTRACT_FAILED. *)
    balances[address] := new_count
  | Sub =>
    maybe_count <- balances[address];
    new_count = 
      let cur_count = get_bal maybe_count in
      builtin sub cur_count one; (* If underflow occurs, it throws CALL_CONTRACT_FAILED. *)
    balances[address] := new_count end
end

procedure HandlePayment(id_: Pair String String)
  payment_id = let fst_element = @fst String String in fst_element id_;
  txID = let snd_element = @snd String String in snd_element id_;
  ssi_init <-& init.dApp; current_impl <-& ssi_init.implementation;
  get_fee <-& current_impl.utility[payment_id][txID]; match get_fee with
  | None => ver <- version; e = { _exception : "SSIDApp-FeeIsNull"; version: ver }; throw e
  | Some fee =>
    is_zero = builtin eq zero_128 fee; match is_zero with
    | True =>
    | False => 
      id <- nft_domain; domain = builtin to_string id;
      get_did <-& ssi_init.did_dns[domain]; match get_did with
        | None => err = CodeIsNull; code = Int32 -13; ThrowError err code
        | Some didx =>
          is_zil = builtin eq payment_id zilID; match is_zil with
            | True =>
              not_enough = builtin lt _amount fee; match not_enough with
                | True => err = CodeIsInsufficient; code = Int32 -14; ThrowError err code
                | False =>
                  accept; msg = let m = { _tag: "AddFunds"; _recipient: didx; _amount: fee } in one_msg m; send msg;
                  refund = builtin sub _amount fee; zero_refund = builtin eq refund zero_128; match zero_refund with
                  | True => | False => rmsg = let m = { _tag: "AddFunds"; _recipient: _sender; _amount: refund } in one_msg m; send rmsg end end
            | False =>
              initId = "init"; get_impl_did <-& ssi_init.did_dns[initId]; match get_impl_did with
                | None => err = CodeDidIsNull; code = Int32 -15; ThrowError err code
                | Some did_ =>
                  get_token_addr <-& did_.services[payment_id]; token_addr = option_bystr20_value get_token_addr;
                  msg = let m = { _tag: "TransferFrom"; _recipient: token_addr; _amount: zero_128;
                    from: _sender;
                    to: didx;
                    amount: fee } in one_msg m; send msg end end end end end
end

procedure HandleBatchPayment(payment_id: String, txID: String, counter: Uint32 )
  ssi_init <-& init.dApp; current_impl <-& ssi_init.implementation;
  get_fee <-& current_impl.utility[payment_id][txID]; match get_fee with
  | None => err = CodeIsNull; code = Int32 -16; ThrowError err code
  | Some fee_ =>
    get_counter = builtin to_uint128 counter; counter_ = match get_counter with
    | Some c => c
    | None => Uint128 0 (* should never happen *)
    end;
    fee = builtin mul fee_ counter_;
    id <- nft_domain; domain = builtin to_string id;
    get_did <-& ssi_init.did_dns[domain]; match get_did with
      | None => err = CodeDidIsNull; code = Int32 -17; ThrowError err code
      | Some didx =>
        is_zil = builtin eq payment_id zilID; match is_zil with
          | True =>
            not_enough = builtin lt _amount fee; match not_enough with
              | True => err = CodeIsInsufficient; code = Int32 -18; ThrowError err code
              | False =>
                accept; msg = let m = { _tag: "AddFunds"; _recipient: didx; _amount: fee } in one_msg m; send msg;
                refund = builtin sub _amount fee; is_zero = builtin eq refund zero_128; match is_zero with
                | True => | False => rmsg = let m = { _tag: "AddFunds"; _recipient: _sender; _amount: refund } in one_msg m; send rmsg end end
          | False =>
            initId = "init"; get_impl_did <-& ssi_init.did_dns[initId]; match get_impl_did with
              | None => err = CodeDidIsNull; code = Int32 -19; ThrowError err code
              | Some did_ =>
                get_token_addr <-& did_.services[payment_id]; token_addr = option_bystr20_value get_token_addr;
                msg = let m = { _tag: "TransferFrom"; _recipient: token_addr; _amount: zero_128;
                  from: _sender;
                  to: didx;
                  amount: fee } in one_msg m; send msg end end end end
end

(* @Requirements: *)
(* - 'to' must not be the zero address. Otherwise, it must throw 'ZeroAddressDestinationError' *)
(* - 'to' must not be '_this_address'. Otherwise, it must throw 'ThisAddressDestinationError' *)
(* - '_sender' must be a minter. Otherwise, it must throw 'NotMinterError' *)
procedure MintToken(to: ByStr20)
  RequireValidDestination to;

  (*IsMinter _sender;*)

  (* generate ID *)
  current_token_id_count <- token_id_count;
  new_token_id_count = builtin add current_token_id_count one;
  token_id_count := new_token_id_count;
  
  (* mint a new token *)
  token_owners[new_token_id_count] := to;

  (* add one to the token owner balance *)
  UpdateBalance add_operation to;
  
  (* add one to the total supply *)
  current_supply <- total_supply;
  new_supply = builtin add current_supply one;
  total_supply := new_supply
end

procedure SetTokenURI(token_id: Uint256, token_uri: String)
  is_empty_string = builtin eq token_uri empty_string;
  match is_empty_string with 
  | True => 
    (* noop *)
  | False =>
    token_uris[token_id] := token_uri
  end
end

procedure HandleMint(info: Pair ByStr20 String)
  match info with
  | Pair to token_uri =>
    domain_id = builtin sha256hash token_uri;
    RequireNotTaken domain_id;
    MintToken to;
    token_id <- token_id_count;
    token_domains[token_id] := domain_id; 
    SetTokenURI token_id token_uri;
    nft_domain_names[domain_id] := token_id;
    nft_dns[domain_id] := to
  end
end

(* @Requirements: *)
(* - 'token_id' must exist. Otherwise, it must throw 'TokenNotFoundError' *)
(* - '_sender' must be a token owner or an operator. Otherwise, it must throw 'NotOwnerOrOperatorError' *)
procedure BurnToken(token_id: Uint256)
  (* Check if token exists *)
  maybe_token_owner <- token_owners[token_id]; match maybe_token_owner with
    | None =>
      err = CodeIsNull; code = Int32 -20; ThrowError err code
    | Some token_owner =>
      RequireOwnerOrOperator token_owner;
      (* Destroy existing token *)
      delete token_owners[token_id];
      delete token_uris[token_id];
      delete spenders[token_id];
  
      get_domain_id <- token_domains[token_id]; domain_id = option_bystr32_value get_domain_id;
      delete nft_domain_names[domain_id];
      delete nft_dns[domain_id];
      delete token_domains[token_id];
  
      (* subtract one from the balance *)
      UpdateBalance sub_operation token_owner;
      (* subtract one from the total supply *)
      current_supply <- total_supply;
      new_supply = builtin sub current_supply one;
      total_supply := new_supply;
  
      ver <- version; e = { _eventname: "SSIDApp_Burn"; version: ver;
        token_owner: token_owner;
        token_id: token_id }; event e end
end

(* @Requirements: *)
(* - 'to' must not be the zero address. Otherwise, it must throw 'ZeroAddressDestinationError' *)
(* - 'to' must not be '_this_address'. Otherwise, it must throw 'ThisAddressDestinationError' *)
(* - 'token_id' must exist. Otherwise, it must throw 'TokenNotFoundError' *)
(* - '_sender' must be a token owner, spender, or operator. Otherwise, it must throw 'NotAllowedToTransferError' *)
(* - '_sender' must not be 'to'. Otherwise, it must throw 'SelfError' *)
procedure TransferToken(to: ByStr20, token_id: Uint256)
  RequireValidDestination to;

  maybe_token_owner <- token_owners[token_id]; match maybe_token_owner with
    | None => (* Token Not Found Error*)
      err = CodeIsNull; code = Int32 -21; ThrowError err code
    | Some token_owner =>
      RequireAccessToTransfer token_owner token_id;
      RequireNotSelf token_owner to;
      
      (* change token_owner for that token_id *)
      token_owners[token_id] := to;
  
      delete spenders[token_id];
  
      (* subtract one from previous token owner balance *)
      UpdateBalance sub_operation token_owner;
      (* add one to the new token owner balance *)
      UpdateBalance add_operation to;
  
      ver <- version; e = { _eventname: "SSIDApp_TransferFrom"; version: ver;
        from: token_owner;
        to: to;
        token_id: token_id }; event e end
end

procedure HandleTransfer(info: Pair ByStr20 Uint256)
  match info with
  | Pair to token_id =>
    TransferToken to token_id end
end

(* @review
  When the migration is active, a domain owner in the NFT DNS can get their domain registered for free. *)
procedure VerifyMigration(domain_id: ByStr32, address: ByStr20, id_: Pair String String)
  RequireNotRegistered domain_id; (* The domain cannot get registered twice. *)
  paused <- is_paused_migration; match paused with
    | True =>
      (* When is_paused_migration is True, then anyone can claim an unregistered domain. *)
      HandlePayment id_
    | False =>
      (* The _origin must match the NFT DNS for the given domain. *)
      VerifyOrigin address end
end

procedure ThrowIfSameDomain(
  a: ByStr32,
  b: ByStr32
  )
  is_same = builtin eq a b; match is_same with
    | False => | True => err = CodeSameValue; code = Int32 -22; ThrowError err code end
end

(***************************************************)
(*              Contract transitions               *)
(***************************************************)

transition TransferFromSuccessCallBack(
  initiator: ByStr20,
  sender: ByStr20,
  recipient: ByStr20,
  amount: Uint128
  )
  RequireNotPaused;
  is_valid = builtin eq initiator _this_address; match is_valid with
    | True => | False => err = CodeWrongSender; code = Int32 -23; ThrowError err code end
end

(* Pauses the contract. Use this when things are going wrong ('circuit breaker'). *)
(* @Requirements: *)
(* - The contract must not be paused. Otherwise, it must throw 'PausedError' *)
(* - '_sender' must be the contract owner. Otherwise, it must throw 'NotContractOwnerError' *)
transition Pause()
  RequireNotPaused;
  RequireContractOwner;

  is_paused := true;
  ver <- version; e = { _eventname: "SSIDApp_Pause"; version: ver;
    isPaused: true }; event e;
  
  msg_to_sender = { _tag: "ZRC6_PauseCallback"; _recipient: _sender; _amount: Uint128 0;
    is_paused: true }; msgs = one_msg msg_to_sender; send msgs
end

transition PauseMigration()
  RequireNotPaused;
  RequireContractOwner;

  is_paused_migration := true;
  ver <- version; e = { _eventname: "SSIDApp_PauseMigration"; version: ver;
    is_paused_migration: true }; event e
end

(* Unpauses the contract. *)
(* @Requirements: *)
(* - The contract must be paused. Otherwise, it must throw 'NotPausedError' *)
(* - '_sender' must be the contract owner. Otherwise, it must throw 'NotContractOwnerError' *)
transition Unpause()
  paused <- is_paused; match paused with
    | True => | False => (* Not Paused Error *)
      err = CodeWrongStatus; code = Int32 -24; ThrowError err code end;
  RequireContractOwner;

  is_paused := false;
  ver <- version; e = { _eventname: "SSIDApp_Unpause"; version: ver;
    isContractPaused: false }; event e;
  
  msg_to_sender = { _tag: "ZRC6_UnpauseCallback"; _recipient: _sender; _amount: Uint128 0;
    is_paused: false
  }; msgs = one_msg msg_to_sender; send msgs
end

transition UnpauseMigration()
  RequireNotPaused;
  paused <- is_paused_migration; match paused with
    | True => | False => (* Not Paused Error *)
      err = CodeWrongStatus; code = Int32 -25; ThrowError err code end;
  RequireContractOwner;

  is_paused_migration := false;
  ver <- version; e = { _eventname: "SSIDApp_UnpauseMigration"; version: ver;
    isMigrationPaused: false }; event e
end

(* Sets 'to' as the royalty recipient. *)
(* @param: to - Royalty recipient address  *)
(* @Requirements: *)
(* - '_sender' must be the contract owner. Otherwise, it must throw 'NotContractOwnerError' *)
(* - 'to' must not be the zero address. Otherwise, it must throw 'ZeroAddressDestinationError' *)
(* - 'to' must not be '_this_address'. Otherwise, it must throw 'ThisAddressDestinationError' *)
transition SetRoyaltyRecipient(to: ByStr20)
  RequireNotPaused;
  RequireContractOwner;
  RequireValidDestination to;
  
  royalty_recipient := to;
  ver <- version; e = { _eventname: "SetRoyaltyRecipient"; version: ver;
    to: to }; event e;
  
  msg_to_sender = { _tag: "ZRC6_SetRoyaltyRecipientCallback"; _recipient: _sender; _amount: Uint128 0;
    to: to }; msgs = one_msg msg_to_sender; send msgs
end

(* Sets 'fee_bps' as royalty fee bps. *)
(* @param: fee_bps - Royalty fee BPS *)
(* @Requirements: *)
(* - '_sender' must be the contract owner. Otherwise, it must throw 'NotContractOwnerError' *)
(* - 'fee_bps' must be in the range of 1 and 10000. Otherwise, it must throw 'InvalidFeeBPSError' *)
transition SetRoyaltyFeeBPS(fee_bps: Uint128)
  RequireNotPaused;
  RequireContractOwner;
  RequireValidRoyaltyFee fee_bps;
  
  royalty_fee_bps := fee_bps;
  ver <- version;e = { _eventname: "SSIDApp_SetRoyaltyFeeBPS"; version: ver;
    royalty_fee_bps: fee_bps }; event e;

  msg_to_sender = { _tag: "ZRC6_SetRoyaltyFeeBPSCallback"; _recipient: _sender; _amount: Uint128 0;
    royalty_fee_bps: fee_bps }; msgs = one_msg msg_to_sender; send msgs
end

(* Sets 'uri' as the base URI. *)
(* @Requirements: *)
(* - '_sender' must be the contract owner. Otherwise, it must throw 'NotContractOwnerError' *)
transition SetBaseURI(uri: String)
  RequireNotPaused;
  RequireContractOwner;
  
  base_uri := uri;
  ver <- version; e = { _eventname: "SSIDApp_SetBaseURI"; version: ver;
    base_uri: uri }; event e;

  msg_to_sender = { _tag: "ZRC6_SetBaseURICallback"; _recipient: _sender; _amount: Uint128 0;
    base_uri: uri }; msgs = one_msg msg_to_sender; send msgs  
end

(* Mints a token with a specific 'token_uri' and transfers it to 'to'. *)
(* Pass empty string to 'token_uri' to use the concatenated token URI. i.e. '<base_uri><token_id>'. *)
(* @param: to - Address of the token recipient *)
(* @param: token_uri - URI of a token *)
(* @Requirements: *)
(* - The contract must not be paused. Otherwise, it must throw 'PausedError' *)
transition Mint(to: ByStr20, token_uri: String)
  RequireNotPaused;
  
  domain_id = builtin sha256hash token_uri;
  id_ = let txID = "BuyNftUsername" in Pair {String String} zilID txID;
  maybe_dns <- nft_dns[domain_id]; match maybe_dns with
    | None => HandlePayment id_
    | Some address => VerifyMigration domain_id address id_ end;
  
  MintToken to;
  token_id <- token_id_count;
  token_domains[token_id] := domain_id;
  SetTokenURI token_id token_uri;
  nft_domain_names[domain_id] := token_id; nft_dns[domain_id] := to;
  ver <- version; e = { _eventname: "SSIDApp_Mint"; version: ver;
    to: to;
    token_id: token_id;
    token_uri: token_uri
  }; event e;

  msg_to_recipient = { _tag: "ZRC6_RecipientAcceptMint"; _recipient: to; _amount: Uint128 0 };
  msg_to_sender = { _tag: "ZRC6_MintCallback"; _recipient: _sender; _amount: Uint128 0;
    to: to;
    token_id: token_id;
    token_uri: token_uri
  }; msgs = two_msgs msg_to_recipient msg_to_sender; send msgs
end

(* Mints a token with a specific 'token_uri' and transfers it to 'to'. *)
(* Pass empty string to 'token_uri' to use the concatenated token URI. i.e. '<base_uri><token_id>'. *)
(* @param: to - Address of the token recipient *)
(* @param: token_uri - URI of a token *)
(* @Requirements: *)
(* - The contract must not be paused. Otherwise, it must throw 'PausedError' *)
transition MintTyron(to: ByStr20, token_uri: ByStr32, id: String)
  RequireNotPaused;

  ThrowIfNullHash token_uri; domain_id = token_uri;
  id_ = let txID = "BuyNftUsername" in Pair {String String} id txID;
  maybe_dns <- nft_dns[domain_id]; match maybe_dns with
    | None => HandlePayment id_
    | Some address => VerifyMigration domain_id address id_ end;
  
  MintToken to;
  token_id <- token_id_count;
  token_domains[token_id] := domain_id;
  nft_domain_names[domain_id] := token_id; nft_dns[domain_id] := to;
  ver <- version; e = { _eventname: "SSIDApp_MintTyron"; version: ver;
    to: to;
    token_id: token_id;
    token_uri: token_uri
  }; event e;
  
  msg_to_recipient = { _tag: "ZRC6_RecipientAcceptMint"; _recipient: to; _amount: Uint128 0 };
  msg_to_sender = { _tag: "ZRC6_MintCallback"; _recipient: _sender; _amount: Uint128 0;
    to: to;
    token_id: token_id;
    token_uri: empty_string
  }; msgs = two_msgs msg_to_recipient msg_to_sender; send msgs
end

(* Mints multiple tokens with 'token_uri's and transfers them to multiple 'to's. *)
(* Pass empty string to 'token_uri' to use the concatenated token URI. i.e. '<base_uri><token_id>'. *)
(* @param: to_token_uri_pair_list - List of Pair (to, token_uri). *)
(* @Requirements: *)
(* - The contract must not be paused. Otherwise, it must throw 'PausedError' *)
transition BatchMint(to_token_uri_pair_list: List (Pair ByStr20 String))
  RequireNotPaused;

  cur_id <- token_id_count;
  start_id = builtin add cur_id one;
  txID = "BuyNftUsername";
  counter = let list_length = @list_length (Pair ByStr20 String) in list_length to_token_uri_pair_list;
  HandleBatchPayment zilID txID counter;
  forall to_token_uri_pair_list HandleMint;
  end_id <- token_id_count;
  
  ver <- version; e = { _eventname: "SSIDApp_BatchMint"; version: ver;
    to_token_uri_pair_list: to_token_uri_pair_list;
    start_id: start_id;
    end_id: end_id
  }; event e;

  msg_to_sender = { _tag: "ZRC6_BatchMintCallback"; _recipient: _sender; _amount: Uint128 0 };
  msgs = one_msg msg_to_sender; send msgs
end

(* Mints multiple tokens with 'token_uri's and transfers them to multiple 'to's. *)
(* Pass empty string to 'token_uri' to use the concatenated token URI. i.e. '<base_uri><token_id>'. *)
(* @param: to_token_uri_pair_list - List of Pair (to, token_uri). *)
(* @Requirements: *)
(* - The contract must not be paused. Otherwise, it must throw 'PausedError' *)
transition BatchMintTyron(to_token_uri_pair_list: List (Pair ByStr20 String), id: String)
  RequireNotPaused;
  cur_id <- token_id_count;
  start_id = builtin add cur_id one;
  txID = "BuyNftUsername";
  counter = let list_length = @list_length (Pair ByStr20 String) in list_length to_token_uri_pair_list;
  HandleBatchPayment id txID counter;
  
  forall to_token_uri_pair_list HandleMint; end_id <- token_id_count;
  ver <- version; e = { _eventname: "SSIDApp_BatchMint"; version: ver;
    to_token_uri_pair_list: to_token_uri_pair_list;
    start_id: start_id;
    end_id: end_id
  }; event e;

  msg_to_sender = { _tag: "ZRC6_BatchMintCallback"; _recipient: _sender; _amount: Uint128 0 };
  msgs = one_msg msg_to_sender; send msgs
end

(* Destroys 'token_id'. *)
(* @param: token_id - Unique ID of the NFT to be destroyed *)
(* @Requirements: *)
(* - The contract must not be paused. Otherwise, it must throw 'PausedError' *)
transition Burn(token_id: Uint256)
  RequireNotPaused;
  (* Check if token exists *)
  maybe_token_owner <- token_owners[token_id]; match maybe_token_owner with
    | None => (* Token Not Found Error *)
      err = CodeIsNull; code = Int32 -26; ThrowError err code
    | Some token_owner =>
      BurnToken token_id;
      
      msg_to_sender = { _tag: "ZRC6_BurnCallback"; _recipient: _sender; _amount: Uint128 0;
        token_owner: token_owner;
        token_id: token_id }; msgs = one_msg msg_to_sender; send msgs end
end

(* Destroys 'token_id_list'. *)
(* @param: token_id_list - List of unique IDs of the NFT to be destroyed *)
(* @Requirements: *)
(* - The contract must not be paused. Otherwise, it must throw 'PausedError' *)
transition BatchBurn(token_id_list: List Uint256)
  RequireNotPaused;

  forall token_id_list BurnToken;
  
  msg_to_sender = { _tag: "ZRC6_BatchBurnCallback"; _recipient: _sender; _amount: Uint128 0 };
  msgs = one_msg msg_to_sender; send msgs
end

(* Sets 'spender' for 'token_id'. *)
(* To remove 'spender' for a token, use 'zero_address'. *)
(* i.e., '0x0000000000000000000000000000000000000000' *)
(* @Requirements: *)
(* - 'token_id' must exist. Otherwise, it must throw 'TokenNotFoundError' *)
(* - '_sender' must be a token owner or an operator. Otherwise, it must throw 'NotOwnerOrOperatorError' *)
(* - '_sender' must not be 'spender'. Otherwise, it must throw 'SelfError' *)
(* - 'spender' must not be already a spender. Otherwise, it must throw 'SpenderFoundError' *)
transition SetSpender(spender: ByStr20, token_id: Uint256)
  RequireNotSelf spender _sender;
  
  maybe_token_owner <- token_owners[token_id]; match maybe_token_owner with
    | None => (* Token Not Found Error *)
      err = CodeIsNull; code = Int32 -27; ThrowError err code
    | Some token_owner =>
      RequireOwnerOrOperator token_owner;
      
      (* Check if the spender exists *)
      maybe_spender <- spenders[token_id]; match maybe_spender with
        | None =>
        | Some cur_spender =>
          has_spender = builtin eq cur_spender spender; match has_spender with 
            | False =>
            | True => (* Spender Found Error *)
              err = CodeInvalidInput; code = Int32 -28; ThrowError err code end end;
        
      spenders[token_id] := spender;
  
      e = {
        _eventname: "SSIDApp_SetSpender";
        token_owner: token_owner;
        spender: spender;
        token_id: token_id
      }; event e;
      msg_to_sender = {
        _tag: "ZRC6_SetSpenderCallback";
        _recipient: _sender;
        _amount: Uint128 0;
        spender: spender;
        token_id: token_id
      };
      msgs = one_msg msg_to_sender; send msgs end
end

(* Adds 'operator' for '_sender'. *)
(* @Requirements: *)
(* - '_sender' must be the token owner. Otherwise, it must throw 'NotTokenOwnerError' *)
(* - '_sender' must not be 'operator'. Otherwise, it must throw 'SelfError' *)
(* - 'operator' must not be already an operator. Otherwise, it must throw 'OperatorFoundError' *)
transition AddOperator(operator: ByStr20)
  RequireNotSelf operator _sender;
  
  maybe_bal <- balances[_sender];
  balance = get_bal maybe_bal;
  
  (* _sender must have at least 1 token *)
  is_balance_zero = builtin eq zero balance; match is_balance_zero with 
    | True =>
      err = CodeIsNull; code = Int32 -29; ThrowError err code
    | False =>
      has_operator <- exists operators[_sender][operator]; match has_operator with
        | False =>  (* Add operator *)
          operators[_sender][operator] := true
        | True => (* Operator Found Error *)
          err = CodeInvalidInput; code = Int32 -29; ThrowError err code end;
      
      e = {
        _eventname: "SSIDApp_AddOperator";
        token_owner: _sender;
        operator: operator
      }; event e;
      msg_to_sender = {
        _tag: "ZRC6_AddOperatorCallback";
        _recipient: _sender;
        _amount: Uint128 0;
        operator: operator
      };
      msgs = one_msg msg_to_sender; send msgs end
end

(* Removes 'operator' for '_sender'. *)
(* @Requirements:  *)
(* - 'operator' must be already an operator of '_sender'. Otherwise, it must throw 'OperatorNotFoundError' *)
transition RemoveOperator(operator: ByStr20)
  has_operator <- exists operators[_sender][operator]; match has_operator with
    | False => (* Operator Not Found Error *)
      err = CodeInvalidInput; code = Int32 -30; ThrowError err code
    | True => (* Remove operator *)
      delete operators[_sender][operator] end;
    
  e = {
    _eventname: "SSIDApp_RemoveOperator";
    token_owner: _sender;
    operator: operator
  }; event e;
  msg_to_sender = {
    _tag: "ZRC6_RemoveOperatorCallback";
    _recipient: _sender;
    _amount: Uint128 0;
    operator: operator
  };
  msgs = one_msg msg_to_sender; send msgs
end

(* Transfers 'token_id' from the token owner to 'to'.  *)
(* @Requirements: *)
(* - The contract must not be paused. Otherwise, it must throw 'PausedError' *)
transition TransferFrom(to: ByStr20, token_id: Uint256)
  RequireNotPaused;
  maybe_token_owner <- token_owners[token_id]; match maybe_token_owner with
    | None => (* Token Not Found Error *)
      err = CodeIsNull; code = Int32 -31; ThrowError err code
    | Some token_owner =>
      TransferToken to token_id;
      msg_to_recipient = {
        _tag: "ZRC6_RecipientAcceptTransferFrom";
        _recipient: to;
        _amount: Uint128 0;
        from: token_owner;
        to: to;
        token_id: token_id
      };
      msg_to_sender = {
        _tag: "ZRC6_TransferFromCallback";
        _recipient: _sender;
        _amount: Uint128 0;
        from: token_owner;
        to: to;
        token_id: token_id
      };
      msgs = two_msgs msg_to_recipient msg_to_sender; send msgs end
end

(* Transfers multiple 'token_id' to multiple 'to'. *)
(* @param: to_token_id_pair_list - List of Pair (to, token_id). *)
(* @Requirements: *)
(* - The contract must not be paused. Otherwise, it must throw 'PausedError' *)
transition BatchTransferFrom(to_token_id_pair_list: List (Pair ByStr20 Uint256))
  RequireNotPaused;
  forall to_token_id_pair_list HandleTransfer;
  
  msg_to_sender = {
    _tag: "ZRC6_BatchTransferFromCallback";
    _recipient: _sender;
    _amount: Uint128 0
  };
  msgs = one_msg msg_to_sender; send msgs
end

transition UpdateDomain( domain: ByStr32 )
  RequireNotPaused; RequireContractOwner; id <- nft_domain;
  ThrowIfSameDomain id domain;
  ssi_init <-& init.dApp; domain_ = builtin to_string domain;
  get_did <-& ssi_init.did_dns[domain_]; match get_did with
    | None => err = CodeDidIsNull; code = Int32 -32; ThrowError err code
    | Some did_ =>
      pending_domain := domain;
      ver <- version; e = { _eventname: "SSIDApp_SetContractOwnershipRecipient"; version: ver;
        to: domain }; event e;
      
      msg_to_sender = { _tag: "ZRC6_SetContractOwnershipRecipientCallback";
        _recipient: _sender;
        _amount: Uint128 0;
        to: did_ }; msgs = one_msg msg_to_sender; send msgs end
end

transition AcceptPendingDomain()
  RequireNotPaused; domain <- pending_domain;
  ssi_init <-& init.dApp; domain_ = builtin to_string domain;
  get_did <-& ssi_init.did_dns[domain_]; match get_did with
    | None => err = CodeDidIsNull; code = Int32 -33; ThrowError err code
    | Some did_ =>
      controller <-& did_.controller; VerifyOrigin controller;

      nft_domain := domain; pending_domain := zero_hash;
      ver <- version; e = { _eventname: "SSIDApp_AcceptContractOwnership"; version: ver;
        contract_owner: _sender }; event e;

      msg_to_sender = { _tag: "ZRC6_AcceptContractOwnershipCallback";
        _recipient: _sender;
        _amount: Uint128 0;
        contract_owner: _sender }; msgs = one_msg msg_to_sender; send msgs end
end

(* Shall change the current permalink for a new one. *)
transition UpdateTokenURI(token_id: Uint256, token_uri: String)
  RequireNotPaused;
  (* Check if token exists *)
  maybe_token_owner <- token_owners[token_id]; match maybe_token_owner with
    | None => (* Token Not Found Error *)
      err = CodeIsNull; code = Int32 -34; ThrowError err code
    | Some token_owner =>
        RequireOwnerOrOperator token_owner;
        
        SetTokenURI token_id token_uri;
        ver <- version; e = { _eventname: "SSIDApp_TokenURIUpdated"; version: ver;
          token_id: token_id }; event e;

        msg_to_sender = { _tag: "SSIDNS_UpdateDomainCallback"; _recipient: _sender; _amount: Uint128 0;
          token_owner: token_owner;
          token_id: token_id }; msgs = one_msg msg_to_sender; send msgs end
end

(* Sets the domain address for a certain token. *)
transition UpdateDomainAddress(token_id: Uint256, new_addr: ByStr20)
  RequireNotPaused;
  (* Check if token exists *)
  maybe_token_owner <- token_owners[token_id]; match maybe_token_owner with
    | None => (* Token Not Found Error *)
      err = CodeIsNull; code = Int32 -35; ThrowError err code
    | Some token_owner =>
        RequireOwnerOrOperator token_owner;
        get_token_domain <- token_domains[token_id]; token_domain = option_bystr32_value get_token_domain;
        
        nft_dns[token_domain] := new_addr;
        ver <- version; e = { _eventname: "SSIDApp_DomainAddressUpdated"; version: ver;
          token_id: token_id }; event e;

        msg_to_sender = { _tag: "SSIDNS_UpdateDomainCallback"; _recipient: _sender; _amount: Uint128 0;
          token_owner: token_owner;
          token_id: token_id }; msgs = one_msg msg_to_sender; send msgs end
end

(* Adds 'minter'.
@Requirements:
- '_sender' must be the contract owner. Otherwise, it must throw 'NotContractOwnerError'
- 'minter' must not be already a minter. Otherwise, it must throw 'MinterFoundError'
transition AddMinter(minter: ByStr20)
  RequireContractOwner;
  has_minter <- exists minters[minter];
  match has_minter with
  | True => 
    error = MinterFoundError;
    Throw error
  | False =>
    minters[minter] := true
  end;
  e = { 
    _eventname: "SSIDApp_AddMinter";
    minter: minter
  }; event e;
  msg_to_sender = { _tag: "ZRC6_AddMinterCallback"; _recipient: _sender; _amount: Uint128 0;
    minter: minter };
  msgs = one_msg msg_to_sender; send msgs
end
        
Removes 'minter'-
@Requirements:
- '_sender' must be the contract owner. Otherwise, it must throw 'NotContractOwnerError'
- 'minter' must be already a minter. Otherwise, it must throw 'MinterNotFoundError'
transition RemoveMinter(minter: ByStr20)
  RequireContractOwner;
  has_minter <- exists minters[minter];
  match has_minter with
  | False =>
    error = MinterNotFoundError;
    Throw error
  | True => 
    delete minters[minter]
  end;
  
  e = { 
    _eventname: "SSIDApp_RemoveMinter";
    minter: minter
  }; event e;
  msg_to_sender = { _tag: "ZRC6_RemoveMinterCallback"; _recipient: _sender; _amount: Uint128 0;
    minter: minter
  };
  msgs = one_msg msg_to_sender; send msgs
end
*)