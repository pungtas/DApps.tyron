(*
  DIDxWallet.tyron: decentralized identifier smart wallet.
  Self-Sovereign Identity Protocol.
  Copyright (C) Tyron Pungtas and its affiliates.

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
*)

scilla_version 0

import PairUtils BoolUtils

library DIDxWallet

  type DIDstatus =
    | Deployed
    | Created
    | Updated
    | Recovered
    | Deactivated

  type Operation =
    | Recovery
    | Update
    | Verify of String
  
  type Action =
    | Add
    | Remove

  type TransferProtocol =
    | Https
    | Git
    | Zilliqa
    | Arweave

  type ServiceEndpoint =
    | Endpoint of TransferProtocol String
    | Address of ByStr20
    
  type DidService =
    | DidService of String ServiceEndpoint  (* the type & endpoint *)
    
  type Document =
    | VerificationMethod of Action String ByStr33  (* string: key purpose OR service ID *)
    | Service of Action String DidService
    
  type Beneficiary =
  | UserDomain of ( Pair String String )
  | BeneficiaryAddr of ByStr20

  let one_msg = fun( msg: Message ) =>
    let nil_msg = Nil{ Message } in Cons{ Message } msg nil_msg

  let two_msgs = fun( msg1: Message ) => fun( msg2: Message ) =>
    let msgs_tmp = one_msg msg2 in Cons{ Message } msg1 msgs_tmp

  type Error =
    | CodeWrongStatus
    | CodeNotOwner
    | CodeWrongCaller
    | CodeWrongSignature
    | CodeUndefinedKey
    | CodeSameKey
    | CodeNotValid

  let make_error = fun( error: Error ) =>
    let result = match error with
    | CodeWrongStatus            => Int32 -1
    | CodeNotOwner               => Int32 -2
    | CodeWrongCaller            => Int32 -3
    | CodeWrongSignature         => Int32 -4
    | CodeUndefinedKey           => Int32 -5
    | CodeSameKey                => Int32 -6
    | CodeNotValid               => Int32 -7
    end in { _exception: "Error"; code: result }
  
  let domain = "did"
  let recovery = Recovery
  let update = Update
  let zilswap = "zilswap"
  
  let option_value = tfun 'A => fun( default: 'A ) => fun( input: Option 'A) =>
    match input with
    | Some v => v
    | None => default
    end
  
  let zero = Uint128 0
  let fifteen_min = Uint128 21
  let zeroByStr20 = 0x0000000000000000000000000000000000000000
  let zeroByStr33 = 0x000000000000000000000000000000000000000000000000000000000000000000
  let zeroByStr64 = 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  let zeroService = let endpoint = Address zeroByStr20 in DidService domain endpoint
  let option_uint128_value = let f = @option_value Uint128 in f zero
  let option_bystr20_value = let f = @option_value ByStr20 in f zeroByStr20
  let option_bystr33_value = let f = @option_value ByStr33 in f zeroByStr33
  let option_bystr64_value = let f = @option_value ByStr64 in f zeroByStr64
  
  let option_service = let f = @option_value DidService in f zeroService 
  let service_addr = fun( getService: Option DidService ) =>
    let service = option_service getService
    in match service with
    | DidService serviceType endpoint =>
        match endpoint with
        | Endpoint transfer addr => zeroByStr20
        | Address addr => addr
        end
    end
 
  (*
  let update_methods: forall 'A. List Document -> Map String ByStr33 -> Map String ByStr33 = tfun 'A => fun(l: List Document) => fun(prevMethods: Map String ByStr33) =>
    let foldl = @list_foldl Document Map String ByStr33
    in let iter = fun(map: Map String ByStr33) => fun(h: Document) =>
      match h with
      | VerificationMethod action purpose key =>
          match action with
            | Add =>
                builtin put map purpose key
            | Remove =>
                builtin remove map purpose
          end
      | _ => map
      end in foldl iter prevMethods l

  let make_endpoint = fun( input: DidService ) =>
    match input with
    | DidService serviceType endpoint =>
        match endpoint with
        | Endpoint transfer addr =>
            match transfer with
            | Https =>
                let prefix = "https://" in let uri = builtin concat prefix addr in
                Pair{ String String } serviceType uri
            | Git =>
                let prefix = "git://" in let uri = builtin concat prefix addr in
                Pair{ String String } serviceType uri
            end
        | Address addr => Pair{ String ByStr20 } serviceType addr
        end
    end

  let update_services: forall 'A. List Document -> Map String Pair String String -> Map String Pair String String = tfun 'A => fun( l: List Document ) => fun( prevServices: Map String Pair String String ) =>
    let foldl = @list_foldl Document Map String Pair String String
    in let iter = fun( map: Map String Pair String String ) => fun( h: Document ) =>
      match h with
      | Service action id didService =>
          match action with
          | Add =>
              let endpoint = make_endpoint didService
              in builtin put map id endpoint
          | Remove =>
              builtin remove map id
          end
      | _ => map
      end in foldl iter prevServices l
    *)
contract DIDxWallet(
  initOwner: ByStr20,    (* the Zilliqa address of the DID owner *)
  init_tyron: ByStr20 with contract    (* the init.tyron smart contract *)
    field services: Map String DidService,
    field dns: Map String ( Map String ByStr20 )
    end
  )
  field did: String = ""    (* the decentralized identifier *)
  field did_status: DIDstatus = Deployed
  
  (* Verification methods
  @key: key purpose
  @value: public key of type "SchnorrSecp256k1VerificationKey2019" *)
  field verification_methods: Map String ByStr33 = Emp String ByStr33
  
  (* Services
  @key: ID
  @value: the type & URI *)
  field services: Map String DidService = Emp String DidService
  
  field owner: ByStr20 = initOwner
  field agent: ByStr20 = initOwner

  field init: ByStr20 with contract
    field services: Map String DidService,
    field dns: Map String ( Map String ByStr20 )
    end = init_tyron
  
  field deadline_block: Uint128 = fifteen_min
  
  field recipient_addr: Map String ByStr20 = Emp String ByStr20
  
  (* The public key for the next DID Update operation *)
  field did_update_key: Option ByStr33 = None{ ByStr33 }
  
  (* The public key for the next DID Recover or Deactivate operation *)
  field did_recovery_key: Option ByStr33 = None{ ByStr33 }
  (* upgrade did keys into verification methods *)
  
  (* The block number when the DID Create operation occurred *)
  field did_created: BNum = BNum 0
  
  (* The block number when the last DID operation occurred *)  
  field ledger_time: BNum = BNum 0
  
  (* A monotonically increasing number representing the amount of DID CRUD transactions that have taken place *)
  field crud_tx_number: Uint128 = zero
  
procedure ThrowError( err: Error )
  e = make_error err; throw e
end

procedure VerifyOwner()
  current_owner <- owner;
  verified = builtin eq current_owner _sender;
  match verified with
  | True =>
  | False => err= CodeNotOwner; ThrowError err
  end
end

procedure VerifyCaller()
  current_owner <- owner;
  is_owner = builtin eq current_owner _sender;
  current_agent <- agent;
  is_agent = builtin eq current_agent _sender;
  verified = orb is_owner is_agent;
  match verified with
  | True =>
  | False => err = CodeWrongCaller; ThrowError err
  end
end

procedure IsOperational()
  this_status <- did_status;
  match this_status with
  | Deactivated => err= CodeWrongStatus; ThrowError err
  | _ =>
  end
end

transition UpdateOwner( addr: ByStr20 )
  IsOperational; VerifyOwner; owner := addr
end

transition UpdateAgent( addr: ByStr20 )
  IsOperational; VerifyOwner; agent := addr
end

procedure ThrowIfNoKey( optKey: Option ByStr33 )
  match optKey with
  | Some key =>
  | None => err = CodeUndefinedKey; ThrowError err
  end
end

procedure ThrowIfSameKey(
  key: ByStr33,
  sndKey: ByStr33
  )
  is_same_key = builtin eq key sndKey;
  match is_same_key with
  | True => err= CodeSameKey; ThrowError err
  | False =>
  end
end

procedure VerifyDIDkeys(
  operation: Operation,
  recoveryKey: Option ByStr33,
  updateKey: Option ByStr33
  )
  get_recovery_key <- did_recovery_key; did_recovery = option_bystr33_value get_recovery_key;
  get_update_key <- did_update_key; did_update = option_bystr33_value get_update_key;
  match operation with
  | Recovery =>
      ThrowIfNoKey recoveryKey; ThrowIfNoKey updateKey;
      recovery_key = option_bystr33_value recoveryKey; update_key = option_bystr33_value updateKey;
      ThrowIfSameKey recovery_key update_key; ThrowIfSameKey did_recovery recovery_key; ThrowIfSameKey did_recovery update_key; ThrowIfSameKey did_update recovery_key; ThrowIfSameKey did_update update_key;
      did_recovery_key := recoveryKey; did_update_key := updateKey
  | Update =>
      ThrowIfNoKey updateKey;
      update_key = option_bystr33_value updateKey;
      ThrowIfSameKey did_update update_key; ThrowIfSameKey did_recovery update_key;
      did_update_key := updateKey
  | _ => (* upgrade verification of tyron key *)
  end
end

(* Update verification methods and services *)
procedure UpdateDocument(
  operation: Operation,
  document: List Document
  )
  match operation with
  | Recovery =>
  | Update =>
  | Verify id =>
  end
  (*
  current_methods <- verification_methods; current_services <- services;
  prev_methods = match operation with
  | Recovery => Emp String ByStr33
  | _ => current_methods
  end;
  update_methods = @update_methods Document; update_services = @update_services Document;
  updated_methods = update_methods document prev_methods; verification_methods := updated_methods;
  prev_services = match operation with
  | Recovery => Emp String Pair String String
  | _ => current_services
  end;
  updated_services = update_services document prev_services; services := updated_services
  *)
end

procedure Timestamp()
  current_block <- &BLOCKNUMBER; ledger_time := current_block;
  latest_tx_number <- crud_tx_number;
  new_tx_number = let incrementor = Uint128 1 in builtin add latest_tx_number incrementor; crud_tx_number := new_tx_number
end

procedure BuyDomainNameNFT( username: Option String )
  match username with
  | None => err = CodeNotValid; ThrowError err
  | Some name =>
      current_init <- init;
      user_domain = Pair{ String String } name domain;
      accept; msg = let m = {
        _tag: "BuyDomainNameNFT"; _recipient: current_init; _amount: _amount;
        userDomain: user_domain
      } in one_msg m; send msg
  end
end

transition DIDcreate(
  username: Option String,
  document: Option( List Document ),
  recoveryKey: Option ByStr33,
  updateKey: Option ByStr33,
  signature: Option ByStr64
  )
  IsOperational; VerifyOwner; VerifyDIDkeys recovery recoveryKey updateKey;
  this_did = let did_prefix = "did:tyron:zil:main:" in let did_suffix = builtin to_string _this_address 
    in builtin concat did_prefix did_suffix;
  did := this_did;
  match document with
  | None => err= CodeNotValid; ThrowError err
  | Some doc => UpdateDocument recovery doc
  end;
  BuyDomainNameNFT username;
  new_status = Created; did_status := new_status;
  current_block <- &BLOCKNUMBER; did_created := current_block; Timestamp
end

(* Verify Schnorr signature - signed data must correspond with a DID Key *)
procedure VerifySignature(
  operation: Operation,
  signedData: ByStr,
  signature: Option ByStr64
  )
  sig = option_bystr64_value signature;
  get_recovery_key <- did_recovery_key;
  get_update_key <- did_update_key;
  current_methods <- verification_methods;
  is_right_signature = match operation with
  | Recovery =>
      let did_recovery = option_bystr33_value get_recovery_key in builtin schnorr_verify did_recovery signedData sig
  | Update =>
      let did_update = option_bystr33_value get_update_key in builtin schnorr_verify did_update signedData sig
  | Verify purpose =>
      let get_key = builtin get current_methods purpose in let key = option_bystr33_value get_key in builtin schnorr_verify key signedData sig
  end;
  match is_right_signature with
    | True =>
    | False => err= CodeWrongSignature; ThrowError err
  end
end

procedure VerifyDocument(
  operation: Operation,
  document: Option( List Document ),
  signature: Option ByStr64
  )
  match document with
  | None => err= CodeNotValid; ThrowError err
  | Some doc =>
      signed_data = let hash = builtin sha256hash doc in builtin to_bystr hash;
      VerifySignature operation signed_data signature; UpdateDocument operation doc
  end
end

transition DIDrecover(
  username: Option String,
  document: Option( List Document ),
  recoveryKey: Option ByStr33,
  updateKey: Option ByStr33,
  signature: Option ByStr64
  )
  IsOperational; VerifyOwner; VerifyDIDkeys recovery recoveryKey updateKey;
  VerifyDocument recovery document signature;
  new_status = Recovered; did_status := new_status; Timestamp
end

transition DIDupdate(
  username: Option String,
  document: Option( List Document ),
  recoveryKey: Option ByStr33,
  updateKey: Option ByStr33,
  signature: Option ByStr64
  )
  IsOperational; VerifyOwner; VerifyDIDkeys update recoveryKey updateKey;
  VerifyDocument update document signature;
  new_status = Updated; did_status := new_status; Timestamp
end

transition DIDdeactivate(
  username: Option String,
  document: Option( List Document ),
  recoveryKey: Option ByStr33,
  updateKey: Option ByStr33,
  signature: Option ByStr64
  ) 
  IsOperational; VerifyOwner;
  VerifyDocument recovery document signature;
  deactivated_key = None{ ByStr33 }; did_update_key := deactivated_key; did_recovery_key := deactivated_key;
  deactivated_methods = Emp String ByStr33; verification_methods := deactivated_methods;
  deactivated_services = Emp String DidService; services := deactivated_services;
  new_status = Deactivated; did_status := new_status; Timestamp
end

(* Receive native funds ($ZIL) and send to owner *)
transition AddFunds()
  IsOperational;
  e = {
    _eventname: "ZILreceived";
    sender: _sender;
    amount: _amount
  }; event e;
  current_owner <- owner;
  accept; msg = let m = {
    _tag: "AddFunds";
    _recipient: current_owner;
    _amount: _amount
  } in one_msg m; send msg
end

procedure Resolve( userDomain: Pair String String )
  current_init <- init
  (* upgrade remote read *)
end

(* Send $ZIL to any recipient that implements the tag (e.g. "AddFunds", "") *)
transition SendFunds(
  tag: String,
  beneficiary: Beneficiary,
  amount: Uint128
  )
  IsOperational; VerifyOwner;
  match beneficiary with
  | UserDomain username_domain => Resolve username_domain
  | BeneficiaryAddr addr =>
      accept; msg = let m = {
        _tag: tag; _recipient: addr; _amount: amount
      } in one_msg m; send msg
  end
  (* upgrade amount _amount *)
end

transition Transfer(
  proxyAddr: ByStr20,
  beneficiary: Beneficiary,
  amount: Uint128
  ) 
  IsOperational; VerifyOwner;
  match beneficiary with
  | UserDomain username_domain => Resolve username_domain
  | BeneficiaryAddr addr =>
      msg = let m = {
        _tag: "Transfer"; _recipient: proxyAddr; _amount: zero;
        to: addr;
        amount: amount
      } in one_msg m ; send msg
    end
end

transition RecipientAcceptTransfer(
  sender: ByStr20,
  recipient: ByStr20,
  amount: Uint128
  )
  IsOperational
end

transition RecipientAcceptTransferFrom(
  initiator: ByStr20,
  sender: ByStr20,
  recipient: ByStr20,
  amount: Uint128
  )
  IsOperational
end

transition TransferSuccessCallBack(
  sender: ByStr20, 
  recipient: ByStr20,
  amount : Uint128
  )
  IsOperational
end

transition TransferFromSuccessCallBack(
  initiator: ByStr20,
  sender: ByStr20,
  recipient: ByStr20,
  amount: Uint128
  )
  IsOperational
end

transition UpdateInit(
  addr: ByStr20 with contract
    field services: Map String DidService,
    field dns: Map String ( Map String ByStr20 )
    end
  )
  IsOperational; VerifyOwner; init := addr
end

transition UpdateDeadline( amount: Uint128 )
  IsOperational; VerifyOwner; deadline_block := amount
end

procedure FetchAddr( id: String )
  current_init <- init; 
  get_service <-& current_init.services[id]; addr = service_addr get_service; recipient_addr[id] := addr
end

procedure IncreaseAllowance(
  addrName: String,
  amount: Uint128
  )
  FetchAddr addrName; get_addr <- recipient_addr[addrName]; addr = option_bystr20_value get_addr;
  FetchAddr zilswap; get_zilswap <- recipient_addr[zilswap]; zilswap_addr = option_bystr20_value get_zilswap;
  msg = let m = {
    _tag: "IncreaseAllowance"; _recipient: addr; _amount: zero;
    spender: zilswap_addr;
    amount: amount
  } in one_msg m ; send msg
end

transition AddLiquidity(
  addrName: String,
  amount: Uint128,
  sndAmount: Uint128
  )
  IsOperational; VerifyCaller; 
  IncreaseAllowance addrName amount;
  get_zilswap <- recipient_addr[zilswap]; zilswap_addr = option_bystr20_value get_zilswap;
  get_addr <- recipient_addr[addrName]; addr = option_bystr20_value get_addr;
  current_block <- &BLOCKNUMBER; deadline <- deadline_block; this_deadline = builtin badd current_block deadline;
  accept; msg = let m = {
    _tag: "AddLiquidity"; _recipient: zilswap_addr; _amount: _amount;
    token_address: addr;
    min_contribution_amount: amount;
    max_token_amount: sndAmount;
    deadline_block: this_deadline
  } in one_msg m ; send msg
end

transition SwapTokensForExactZIL(
  addrName: String,
  amount: Uint128,
  sndAmount: Uint128
  )
  IsOperational; VerifyCaller; IncreaseAllowance addrName amount;
  get_zilswap <- recipient_addr[zilswap]; zilswap_addr = option_bystr20_value get_zilswap;
  get_addr <- recipient_addr[addrName]; addr = option_bystr20_value get_addr;
  current_block <- &BLOCKNUMBER; deadline <- deadline_block; this_deadline = builtin badd current_block deadline;
  current_owner <- owner;
  msg = let m = {
    _tag: "SwapTokensForExactZIL"; _recipient: zilswap_addr; _amount: zero;
    token_address: addr;
    max_token_amount: amount;
    zil_amount: sndAmount;
    deadline_block: this_deadline;
    recipient_address: current_owner
  } in one_msg m ; send msg
end
