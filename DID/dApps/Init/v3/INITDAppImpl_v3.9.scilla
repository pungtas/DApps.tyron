
      (* v3.9
        INIT DAPP: SSI Initialization & DNS <> Implementation smart contract
        Tyron Self-Sovereign Identity Protocol
        Copyright Tyron Mapu Community Interest Company 2022. All rights reserved.
        You acknowledge and agree that Tyron Mapu Community Interest Company (Tyron) own all legal right, title and interest in and to the work, software, application, source code, documentation and any other documents in this repository (collectively, the Program), including any intellectual property rights which subsist in the Program (whether those rights happen to be registered or not, and wherever in the world those rights may exist), whether in source code or any other form.
        Subject to the limited license below, you may not (and you may not permit anyone else to) distribute, publish, copy, modify, merge, combine with another program, create derivative works of, reverse engineer, decompile or otherwise attempt to extract the source code of, the Program or any part thereof, except that you may contribute to this repository.
        You are granted a non-exclusive, non-transferable, non-sublicensable license to distribute, publish, copy, modify, merge, combine with another program or create derivative works of the Program (such resulting program, collectively, the Resulting Program) solely for Non-Commercial Use as long as you:
        1. give prominent notice (Notice) with each copy of the Resulting Program that the Program is used in the Resulting Program and that the Program is the copyright of Tyron; and
        2. subject the Resulting Program and any distribution, publication, copy, modification, merger therewith, combination with another program or derivative works thereof to the same Notice requirement and Non-Commercial Use restriction set forth herein.
        Non-Commercial Use means each use as described in clauses (1)-(3) below, as reasonably determined by Tyron in its sole discretion:
        1. personal use for research, personal study, private entertainment, hobby projects or amateur pursuits, in each case without any anticipated commercial application;
        2. use by any charitable organization, educational institution, public research organization, public safety or health organization, environmental protection organization or government institution; or
        3. the number of monthly active users of the Resulting Program across all versions thereof and platforms globally do not exceed 10,000 at any time.
        You will not use any trade mark, service mark, trade name, logo of Tyron or any other company or organization in a way that is likely or intended to cause confusion about the owner or authorized user of such marks, names or logos.
        If you have any questions, comments or interest in pursuing any other use cases, please reach out to us at mapu@ssiprotocol.com.*)
        
        scilla_version 0
        import BoolUtils ListUtils IntUtils
        
        library InitI
          type DidStatus =
            | Created
            | Updated
            | Deactivated
        
          type Operation =
            | Recovery
            | Update
          
          type Action =
            | Add
            | Remove
        
          type TransferProtocol =
            | Https
            | Git
        
          type BlockchainType =
            | Zilliqa of ByStr20
            | Other of String
        
          type Endpoint =
            | Address of BlockchainType
            | Uri of String TransferProtocol String   (* type, transfer protocol & uri *)
          
          type Document =
            | VerificationMethod of Action String ByStr33 String (* add/remove, key purpose, public key & encrypted private key *)
            | Service of Action String Endpoint (* add/remove, service ID & service *) 
          
          let ssi = "ssi" 
          let did = "did"
          let empty_string = ""
          let empty_map = Emp String String
          
          let update = "update"
          let recovery = "socialrecovery"
          let actionAdd = "add"
          let actionRemove = "remove"
          let add_ = Add
          let remove_ = Remove
          let empty_methods = Emp String ByStr33
          let empty_dkms = Emp String String
          let empty_services = Emp String ByStr20
          let empty_services_ = Emp String Endpoint
          let empty_guardians = Emp ByStr32 Bool
          let empty_domains = Emp String ByStr20
        
          let one_msg = fun( msg: Message ) =>
            let nil_msg = Nil{ Message } in Cons{ Message } msg nil_msg
          
          let two_msgs =
            fun( msg1: Message ) => fun( msg2: Message ) =>
            let msgs_tmp = one_msg msg2 in Cons{ Message } msg1 msgs_tmp
        
          let zero_128 = Uint128 0
          let zero_256 = Uint256 0
          let one_256 = Uint256 1
          let zeroByStr20 = 0x0000000000000000000000000000000000000000
          let zeroByStr32 = 0x0000000000000000000000000000000000000000000000000000000000000000
          let zeroByStr33 = 0x000000000000000000000000000000000000000000000000000000000000000000
          let zeroByStr64 = 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
          let zeroByStr = builtin to_bystr zeroByStr20
        
          let option_value = 
            tfun 'A => fun( default: 'A ) => fun( input: Option 'A) => match input with
            | Some v => v
            | None => default end
          let option_uint256 = let f = @option_value Uint256 in f zero_256
          let option_bystr20_value = let f = @option_value ByStr20 in f zeroByStr20
          let option_bystr33_value = let f = @option_value ByStr33 in f zeroByStr33
          let option_bystr64_value = let f = @option_value ByStr64 in f zeroByStr64
        
          type Beneficiary =
            | NftUsername of String String (* Domain Name & Subdomain *)
            | Recipient of ByStr20
        
          let true = True
          let false = False
          let zilID = "zil"
          
          let compare_participant = fun( addr: ByStr20 ) => fun( participant: ByStr20 ) => builtin eq addr participant
          let get_bal = fun ( maybe_bal: Option Uint256 ) =>
            match maybe_bal with
            | None => zero_256
            | Some bal => bal end
        
        contract InitI(
          symbol: String,
          initial_base_uri: String,
          init_username: String, 
          init: ByStr20 with contract
            field dns: Map String ByStr20,
            field did_dns: Map String ByStr20 with contract
              field did: String,
              field nft_username: String,
              field controller: ByStr20,
              field version: String,
              field verification_methods: Map String ByStr33,
              field services: Map String ByStr20,
              field social_guardians: Map ByStr32 Bool,
              field did_domain_dns: Map String ByStr20,
              field deadline: Uint128 end end,
          did_methods: Map String ByStr33,
          did_dkms: Map String String,
          did_services: Map String ByStr20,
          init_free_list: List ByStr20,
          init_tydra_free_list: List ByStr20,
          init_token_uris: Map String Map ByStr32 String,
          init_tydras: Map String Map String String,
          init_token_id_count: Map String Uint256,
          init_balances: Map String Map ByStr20 Uint256,
          init_utility: Map String Map String Uint128
          )
          field token_symbol: String = symbol
          field base_uri: String = initial_base_uri
          field tydra_id: String = "nessy"
          field token_uris: Map String Map ByStr32 String = init_token_uris
          field tydras: Map String Map String String = init_tydras
          field token_id_count: Map String Uint256 = init_token_id_count
          
          (* Mapping from token owner to the number of existing tokens *)
          field balances: Map String Map ByStr20 Uint256 = init_balances
        
          (* tyronZIL W3C Decentralized Identifier *)
          field did: String = let did_prefix = "did:tyron:zil:main:" in let did_suffix = builtin to_string _this_address in
            builtin concat did_prefix did_suffix   (* the tyronZIL W3C decentralized identifier *)
          field nft_username: String = init_username
          field pending_username: String = empty_string
          field controller: ByStr20 = zeroByStr20
          field did_status: DidStatus = Created
          field version: String = "INITDAppImpl_v3.9.1"   (* @xalkan *)
          
          (* Verification methods @key: key purpose @value: public DID key *)
          field verification_methods: Map String ByStr33 = did_methods
          
          (* Decentralized Key Management System *)
          field dkms: Map String String = did_dkms
          
          (* Services @key: ID @value: endpoint *)
          field services: Map String ByStr20 = did_services
          field services_: Map String Endpoint = empty_services_
        
          field social_guardians: Map ByStr32 Bool = empty_guardians
          
          field did_domain_dns: Map String ByStr20 = let emp = Emp String ByStr20 in
            builtin put emp did _this_address
          field deadline: Uint128 = Uint128 10
        
          field did_hash: ByStr = zeroByStr
          
          (* The block number when the last DID CRUD operation occurred *)  
          field ledger_time: BNum = BNum 0
          
          (* A monotonically increasing number representing the amount of DID CRUD transactions that have taken place *)
          field tx_number: Uint128 = zero_128
          
          field paused: Bool = False
          field closed: Bool = False
        
          field utility: Map String Map String Uint128 = init_utility
        
          field free_list: List ByStr20 = init_free_list
          field tydra_free_list: List ByStr20 = init_tydra_free_list
        
        procedure IsPaused()
          current_status <- did_status; match current_status with
            | Deactivated => e = { _exception : "INITDAppImpl-WrongStatus" }; throw e
            | _ =>
              is_paused <- paused; match is_paused with
                | True => | False => e = { _exception : "INITDAppImpl-IsNotPaused" }; throw e end end end
        
        procedure IsOperational()
          current_status <- did_status; match current_status with
            | Deactivated => e = { _exception : "INITDAppImpl-WrongStatus" }; throw e
            | _ =>
              is_paused <- paused; match is_paused with
                | False => | True => e = { _exception : "INITDAppImpl-IsPaused" }; throw e end end end
        
        procedure VerifyController()
          current_username <- nft_username;
          get_did <-& init.did_dns[current_username]; match get_did with
            | None => e = { _exception : "INITDAppImpl-DidIsNull" }; throw e
            | Some did_ =>
              current_controller <-& did_.controller;
              verified = builtin eq _origin current_controller; match verified with
                | True => | False => e = { _exception : "INITDAppImpl-WrongCaller" }; throw e end;
              controller := current_controller end end
        
        procedure Timestamp()
          current_block <- &BLOCKNUMBER; ledger_time := current_block;
          latest_tx_number <- tx_number;
          new_tx_number = let incrementor = Uint128 1 in builtin add latest_tx_number incrementor; tx_number := new_tx_number end
        
        procedure RequireValidDestination( to: ByStr20 )
          (* Reference: https://github.com/ConsenSys/smart-contract-best-practices/blob/master/docs/tokens.md *)
          is_zeroByStr20 = builtin eq to zeroByStr20; match is_zeroByStr20 with
            | False => | True => e = { _exception : "INITDAppImpl-ZeroAddressDestinationError" }; throw e end;
          is_this_address = builtin eq to _this_address; match is_this_address with
            | False => | True => e = { _exception : "INITDAppImpl-ThisAddressDestinationError" }; throw e end end
        
        procedure ThrowIfSameName(
          a: String,
          b: String
          )
          is_same = builtin eq a b; match is_same with
            | False => | True => e = { _exception : "INITDAppImpl-SameUsername" }; throw e end end
        
        transition Pause()
          IsOperational; VerifyController; paused := true;
          e = { _eventname: "SmartContractPaused";
            pauser: _origin }; event e;
          Timestamp end
        
        transition Unpause()
          IsPaused; VerifyController; paused := false;
          e = { _eventname: "SmartContractUnpaused";
            pauser: _origin }; event e;
          Timestamp end
        
        transition UpdateUsername(
          username: String,
          tyron: Option Uint128
          )
          IsOperational; VerifyController;
          current_username <- nft_username; ThrowIfSameName current_username username;
          get_did <-& init.did_dns[username]; match get_did with
            | None => e = { _exception : "INITDAppImpl-DidIsNull" }; throw e
            | Some did_ => pending_username := username end;
          Timestamp end
        
        transition AcceptPendingUsername()
          IsOperational; current_pending <- pending_username;
          get_did <-& init.did_dns[current_pending]; match get_did with
            | None => e = { _exception : "INITDAppImpl-DidIsNull" }; throw e
            | Some did_ =>
              new_controller <-& did_.controller;
              verified = builtin eq _origin new_controller; match verified with
                | True => | False => e = { _exception : "INITDAppImpl-WrongCaller" }; throw e end;
              nft_username := current_pending; pending_username := empty_string;
              controller := new_controller end;
          Timestamp end
        
        (* Verify Schnorr signature - signed data must correspond with a DID key *)
        procedure VerifySignature(
          id: String,
          signedData: ByStr,
          signature: ByStr64
          )
          get_did_key <- verification_methods[id]; did_key = option_bystr33_value get_did_key;
          is_right_signature = builtin schnorr_verify did_key signedData signature; match is_right_signature with
            | True => | False => e = { _exception : "INITDAppImpl-WrongSignature" }; throw e end end
        
        procedure ThrowIfNoKey( optKey: Option ByStr33 )
          match optKey with
          | Some key => | None => e = { _exception: "DIDxWALLET-UndefinedKey" }; throw e end end
        
        procedure HashDocument( document: Document )
          doc_hash <- did_hash;
          element_hash = match document with
          | VerificationMethod action purpose key encrypted =>
            match action with
            | Add =>
              let h1 = builtin sha256hash actionAdd in
              let h2 = builtin sha256hash purpose in
              let h3 = builtin sha256hash key in
              let h4 = builtin sha256hash encrypted in
              let h1_2 = builtin concat h1 h2 in
              let h1_3 = builtin concat h1_2 h3 in
              let hash = builtin concat h1_3 h4 in
              builtin to_bystr hash
            | Remove =>
              let h1 = builtin sha256hash actionRemove in
              let h2 = builtin sha256hash purpose in
              let hash = builtin concat h1 h2 in
              builtin to_bystr hash end
          | Service action id endpoint =>
              match action with
              | Add =>
                let h1 = builtin sha256hash actionAdd in
                let h2 = builtin sha256hash id in
                match endpoint with
                | Uri eType transfer uri =>
                  let h3 = builtin sha256hash uri in
                  let h1_2 = builtin concat h1 h2 in
                  let hash = builtin concat h1_2 h3 in
                  builtin to_bystr hash
                | Address address =>
                  match address with
                  | Zilliqa addr =>
                    let h3 = builtin sha256hash addr in
                    let h1_2 = builtin concat h1 h2 in
                    let hash = builtin concat h1_2 h3 in
                    builtin to_bystr hash
                  | Other addr =>
                    let h3 = builtin sha256hash addr in
                    let h1_2 = builtin concat h1 h2 in
                    let hash = builtin concat h1_2 h3 in
                    builtin to_bystr hash end end
              | Remove =>
                let h1 = builtin sha256hash actionRemove in
                let h2 = builtin sha256hash id in
                let hash = builtin concat h1 h2 in
                builtin to_bystr hash end end;
          new_doc_hash = builtin concat doc_hash element_hash;
          did_hash := new_doc_hash end
        
        procedure UpdateDocument( document: Document )
          match document with
          | VerificationMethod action purpose key encrypted =>
            match action with
            | Add =>
              verification_methods[purpose] := key;
              dkms[purpose] := encrypted
            | Remove =>
              key_exists <- exists verification_methods[purpose];
              match key_exists with
              | True =>
                delete verification_methods[purpose];
                delete dkms[purpose]
              | False => e = { _exception: "DIDxWALLET-RemoveNoKey" }; throw e end end
          | Service action id endpoint =>
            match action with
            | Add =>
              match endpoint with
              | Address address =>
                match address with
                | Zilliqa addr => services[id] := addr
                | Other adrr => services_[id] := endpoint end
              | Uri eType protocol uri => services_[id] := endpoint end
            | Remove =>
              is_service <- exists services[id];
              is_service_ <- exists services_[id];
              service_exists = orb is_service is_service_;
              match service_exists with
              | True => delete services[id]; delete services_[id]
              | False => e = { _exception: "DIDxWALLET-RemoveNoService" }; throw e end end end end
        
        procedure VerifyDocument(
          document: List Document,
          signature: Option ByStr64,
          tyron: Option Uint128
          )
          (*SupportTyron tyron;*) current_controller <- controller;
          verified = builtin eq _origin current_controller; match verified with
            | True => forall document UpdateDocument
            | False =>
                get_update_key <- verification_methods[update]; update_key = option_bystr33_value get_update_key;
                forall document HashDocument; doc_hash <- did_hash;
                sig = option_bystr64_value signature; VerifySignature update doc_hash sig; did_hash := zeroByStr;
                forall document UpdateDocument;
                get_new_update_key <- verification_methods[update]; new_update = option_bystr33_value get_new_update_key;
                is_same_key = builtin eq update_key new_update; match is_same_key with
                | False => | True => e = { _exception: "DIDxWALLET-SameUpdateKey" }; throw e end end end
        
        transition DidUpdate(
          document: List Document,
          signature: Option ByStr64,
          tyron: Option Uint128
          )
          current_status <- did_status; match current_status with
            | Created => VerifyDocument document signature tyron
            | Updated => VerifyDocument document signature tyron
            (*| Recovered => VerifyController tyron; forall document UpdateDocument*)
            | _ => e = { _exception: "DIDxWALLET-WrongStatus" }; throw e end;
          new_status = Updated; did_status := new_status;
          Timestamp end
        
        transition DidDeactivate(
          document: List Document,
          signature: Option ByStr64,
          tyron: Option Uint128
          ) 
          IsOperational; VerifyDocument document signature tyron;
          did := empty_string; controller := zeroByStr20; social_guardians := empty_guardians;
          verification_methods := empty_methods; dkms := empty_map;
          services := empty_services; services_ := empty_services_;
          did_domain_dns := empty_domains; (*nft_dns := empty_map;*) deadline := zero_128;
          new_status = Deactivated; did_status := new_status;
          Timestamp end
        
        transition Dns(
          addr: ByStr20,
          domain: String,
          didKey: ByStr33,
          encrypted: String,
          tyron: Option Uint128
          )
          current_status <- did_status; match current_status with
            | Created => | Updated =>
            | _ => e = { _exception : "INITDAppImpl-WrongStatus" }; throw e end;
          VerifyController;
          verification_methods[domain] := didKey; dkms[domain] := encrypted; did_domain_dns[domain] := addr; 
          new_status = Updated; did_status := new_status;
          Timestamp end
        
        transition UpdateDeadline(
          val: Uint128,
          tyron: Option Uint128
          )
          IsOperational; VerifyController; deadline := val;
          Timestamp end
        
        transition IncreaseAllowance(
          addrName: String,
          spender: ByStr20,
          amount: Uint128,
          tyron: Option Uint128
          )
          IsOperational; VerifyController;
          get_token_addr <- services[addrName]; token_addr = option_bystr20_value get_token_addr;
          msg = let m = { _tag: "IncreaseAllowance"; _recipient: token_addr; _amount: zero_128;
            spender: spender;
            amount: amount } in one_msg m ; send msg;
          Timestamp end
        
        transition DecreaseAllowance(
          addrName: String,
          spender: ByStr20,
          amount: Uint128,
          tyron: Option Uint128
          )
          IsOperational; VerifyController;
          get_token_addr <- services[addrName]; token_addr = option_bystr20_value get_token_addr;
          msg = let m = { _tag: "DecreaseAllowance"; _recipient: token_addr; _amount: zero_128;
            spender: spender;
            amount: amount } in one_msg m ; send msg;
          Timestamp end
        
        (* Receive $ZIL native funds *)
        transition AddFunds()
          IsOperational; accept; Timestamp end
        
        (* Send $ZIL to any recipient that implements the tag, e.g. "AddFunds", "", etc. *)
        transition SendFunds(
          tag: String,
          beneficiary: Beneficiary,
          amount: Uint128,
          tyron: Option Uint128
          )
          IsOperational; VerifyController;
          match beneficiary with
          | NftUsername username_ domain_ =>
            is_ssi = builtin eq domain_ empty_string; match is_ssi with
              | True =>
                get_addr <-& init.dns[username_]; addr = option_bystr20_value get_addr; RequireValidDestination addr;
                msg = let m = { _tag: tag; _recipient: addr; _amount: amount } in one_msg m; send msg
              | False =>
                get_did <-& init.did_dns[username_]; match get_did with
                  | None => e = { _exception: "INITDAppImpl-DidIsNull" }; throw e
                  | Some did_ =>
                    is_did = builtin eq domain_ did; match is_did with
                      | True => msg = let m = { _tag: tag; _recipient: did_; _amount: amount } in one_msg m; send msg
                      | False =>
                        get_domain_addr <-& did_.did_domain_dns[domain_]; domain_addr = option_bystr20_value get_domain_addr;
                        msg = let m = { _tag: tag; _recipient: domain_addr; _amount: amount } in one_msg m; send msg end end end
          | Recipient addr_ =>
            RequireValidDestination addr_;
            msg = let m = { _tag: tag; _recipient: addr_; _amount: amount } in one_msg m; send msg end;
          Timestamp end
        
        transition Transfer(
          addrName: String,
          beneficiary: Beneficiary,
          amount: Uint128,
          tyron: Option Uint128
          )
          IsOperational; VerifyController;
          get_token_addr <- services[addrName]; token_addr = option_bystr20_value get_token_addr;
          match beneficiary with
          | NftUsername username_ domain_ =>
            is_ssi = builtin eq domain_ empty_string; match is_ssi with
              | True =>
                get_addr <-& init.dns[username_]; addr = option_bystr20_value get_addr; RequireValidDestination addr;
                msg = let m = { _tag: "Transfer"; _recipient: token_addr; _amount: zero_128;
                  to: addr;
                  amount: amount } in one_msg m ; send msg
              | False =>
                get_did <-& init.did_dns[username_]; match get_did with
                  | None => e = { _exception : "INITDAppImpl-DidIsNull" }; throw e
                  | Some did_ =>
                    is_did = builtin eq domain_ did; match is_did with
                      | True =>
                        msg = let m = { _tag: "Transfer"; _recipient: token_addr; _amount: zero_128;
                        to: did_;
                        amount: amount } in one_msg m ; send msg
                      | False =>
                        get_domain_addr <-& did_.did_domain_dns[domain_]; domain_addr = option_bystr20_value get_domain_addr;
                        msg = let m = { _tag: "Transfer"; _recipient: token_addr; _amount: zero_128;
                          to: domain_addr;
                          amount: amount } in one_msg m ; send msg end end end
          | Recipient addr_ =>
            RequireValidDestination addr_;
            msg = let m = { _tag: "Transfer"; _recipient: token_addr; _amount: zero_128;
              to: addr_;
              amount: amount } in one_msg m ; send msg end;
          Timestamp end
        
        transition RecipientAcceptTransfer( sender: ByStr20, recipient: ByStr20, amount: Uint128 ) IsOperational; Timestamp end
        
        transition RecipientAcceptTransferFrom( initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128 ) IsOperational; Timestamp end
        
        transition TransferSuccessCallBack( sender: ByStr20, recipient: ByStr20, amount : Uint128 ) IsOperational end
        
        transition TransferFromSuccessCallBack( initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128 ) IsOperational end
        
        procedure ThrowIfNotProxy()
          verified = builtin eq init _sender; match verified with
            | True => | False => e = { _exception : "INITDAppImpl-NotProxy" }; throw e end end
        
        procedure IsNotNull( addr: ByStr20 )
          is_null = builtin eq addr zeroByStr20; match is_null with
            | False => | True => e = { _exception : "INITDAppImpl-AddressIsNull" }; throw e end end
        
        transition Close()
          IsOperational; VerifyController;
          closed := true;
          Timestamp end
        
        transition Open()
          IsOperational; VerifyController;
          closed := false;
          Timestamp end
        
        procedure IsClosed()
          is_closed <- closed; match is_closed with
            | False => | True => e = { _exception : "INITDAppImpl-IsClosed" }; throw e end end
        
        transition AddUtility(
          id: String,
          txID: String,
          fee: Uint128
          )
          IsOperational; VerifyController;
          utility[id][txID] := fee;
          Timestamp end
          
        transition RemoveUtility(
          id: String,
          txID: String
          )
          IsOperational; VerifyController;
          delete utility[id][txID];
          Timestamp end
        
        procedure UpdateFreeList_( addr: ByStr20 )
          list <- free_list;
          list_updated = Cons{ ByStr20 } addr list;
          free_list := list_updated end
        
        transition UpdateFreeList( val: List ByStr20 )
          IsOperational; VerifyController;
          forall val UpdateFreeList_;
          Timestamp end
        
        procedure UpdateTydraFreeList_( addr: ByStr20 )
          list <- tydra_free_list;
          list_updated = Cons{ ByStr20 } addr list;
          tydra_free_list := list_updated end
        
        transition UpdateTydraFreeList( val: List ByStr20 )
          IsOperational; VerifyController;
          forall val UpdateTydraFreeList_;
          Timestamp end
        
        transition SetTydra( id: String )
          VerifyController; tydra_id := id;
          e = { _eventname: "SetTydra";
            tydra_id: id }; event e;
          msg = let m = { _tag: "SetTydraCallback"; _recipient: _origin; _amount: zero_128;
            tydra_id: id } in one_msg m; send msg end
        
        procedure SetTokenURI(
          tydra: String,
          token_id: ByStr32,
          token_uri: String
          )
          is_empty_string = builtin eq token_uri empty_string; match is_empty_string with 
            | True => | False => token_uris[tydra][token_id] := token_uri end end
        
        (* Sets "uri" as the base URI. *)
        (* @Requirements:
          * "_origin" must be the contract owner. Otherwise, it must throw "NotContractOwnerError" *)
        transition SetBaseURI(uri: String)
          VerifyController; base_uri := uri;
          e = { _eventname: "SetBaseURI";
            base_uri: uri }; event e;
          msg = let m = { _tag: "ZRC6_SetBaseURICallback"; _recipient: _origin; _amount: zero_128;
            base_uri: uri } in one_msg m; send msg end
        
        procedure UpdateBalance(
          tydra: String,
          operation: Action,
          address: ByStr20
          )
          match operation with
          | Add =>
            maybe_count <- balances[tydra][address];
            new_count = 
              let cur_count = get_bal maybe_count in
              (* if overflow occurs, it throws CALL_CONTRACT_FAILED *)
              builtin add cur_count one_256; balances[tydra][address] := new_count
          | Remove =>
            maybe_count <- balances[tydra][address];
            new_count = 
              let cur_count = get_bal maybe_count in
              (* if underflow occurs, it throws CALL_CONTRACT_FAILED *)
              builtin sub cur_count one_256; balances[tydra][address] := new_count end end
        
        (* @Requirements:
          * - "to" must not be the zero address. Otherwise, it must throw "ZeroAddressDestinationError"
          * - "to" must not be "_this_address". Otherwise, it must throw "ThisAddressDestinationError" *)
        procedure MintTydraToken(
          tydra: String,
          token_id: ByStr32,
          dID: ByStr20
          )
          get_current_token_id_count <- token_id_count[tydra]; current_token_id_count = option_uint256 get_current_token_id_count;
          new_token_id_count = builtin add current_token_id_count one_256;
          token_id_count[tydra] := new_token_id_count;
          
          (* add one to the token owner balance *)
          UpdateBalance tydra add_ dID;
          token_id_ = builtin to_string token_id; tydras[token_id_][tydra] := ssi
          end
        
        transition MintTydraNft(
          id: String,
          token_id: ByStr32,
          token_uri: String
          )
          IsOperational; token_id_ = builtin to_string token_id;
          get_did <-& init.did_dns[token_id_]; match get_did with
            | None => e = { _exception : "INITDAppImpl-DidIsNull" }; throw e
            | Some did_ =>
              current_controller <-& did_.controller;
              verified = builtin eq _origin current_controller; match verified with
                | True => | False => e = { _exception : "INITDAppImpl-WrongCaller" }; throw e end;
              list_part = @list_mem ByStr20; list <- tydra_free_list;
              is_participant = list_part compare_participant _origin list;
              match is_participant with
              | True =>
                list_filter = @list_filter ByStr20; remove_participant = fun( participant: ByStr20 )
                  => let is_addr = builtin eq _origin participant in negb is_addr;
                list_updated = list_filter remove_participant list;
                tydra_free_list := list_updated
              | False =>
                  txID = "MintTydraNft";
                  get_fee <- utility[id][txID]; match get_fee with
                  | None => e = { _exception : "INITDAppImpl-FeeIsNull" }; throw e
                  | Some fee =>
                    (* the sender can be an EOA or smart contract wallet *)
                    is_zil = builtin eq id zilID; match is_zil with
                      | True =>
                        not_enough = builtin lt _amount fee; match not_enough with
                          | True => e = { _exception : "INITDAppImpl-InsufficientZIL" }; throw e
                          | False =>
                            accept; refund = builtin sub _amount fee; is_zero = builtin eq refund zero_128; match is_zero with
                            | True => | False => msg = let m = { _tag: "AddFunds"; _recipient: _sender; _amount: refund } in one_msg m; send msg end end
                      | False =>
                        get_token_addr <- services[id]; token_addr = option_bystr20_value get_token_addr;
                        dao_domain <- nft_username; get_addr <-& init.dns[dao_domain]; dao_xwallet = option_bystr20_value get_addr;
                        msg = let m = { _tag: "TransferFrom"; _recipient: token_addr; _amount: zero_128;
                          from: _sender;
                          to: dao_xwallet;
                          amount: fee } in one_msg m; send msg end end end;
            (* An NFT Domain Name cannot mint the same Tydra twice *)
            tydra <- tydra_id;
            get_uri <- token_uris[tydra][token_id]; match get_uri with
              | Some uri => e = { _exception : "INITDAppImpl-UriIsNotsNull" }; throw e
              | None =>
                MintTydraToken tydra token_id did_; SetTokenURI tydra token_id token_uri end end;
          e = { _eventname: "MintTydra";
            to: _origin;
            token_id: token_id;
            token_uri: token_uri
          }; event e;
          msg_to_recipient = {
            _tag: "ZRC6_RecipientAcceptMint";
            _recipient: _sender;
            _amount: zero_128
          };
          msg_to_sender = {
            _tag: "MintCallback";
            _recipient: _origin;
            _amount: zero_128;
            to: _sender;
            token_id: token_id;
            token_uri: token_uri
          }; msgs = two_msgs msg_to_recipient msg_to_sender; send msgs;
          Timestamp end
        
        procedure TransferTydraToken(
          tydra: String,
          token_id: ByStr32,
          to_token_id: ByStr32
          )
          get_to_uri <- token_uris[tydra][to_token_id]; match get_to_uri with
            | None => | Some uri => e = { _exception : "INITDAppImpl-ToUriIsNotNull" }; throw e end;
          token_id_ = builtin to_string token_id;
          to_token_id_ = builtin to_string to_token_id;
          get_did <-& init.did_dns[token_id_]; match get_did with
            | None => e = { _exception : "INITDAppImpl-DidIsNull" }; throw e
            | Some did_ =>
              get_to_did <-& init.did_dns[to_token_id_]; match get_to_did with
                | None => e = { _exception : "INITDAppImpl-ToDidIsNull" }; throw e
                | Some to_did =>
                  new_controller <-& to_did.controller;
                  get_uri <- token_uris[tydra][token_id]; match get_uri with
                    | None => e = { _exception : "INITDAppImpl-FromUriIsNull" }; throw e
                    | Some uri =>
                      delete token_uris[tydra][token_id]; UpdateBalance tydra remove_ did_; delete tydras[token_id_][tydra];
                      SetTokenURI tydra to_token_id uri; UpdateBalance tydra add_ to_did; tydras[to_token_id_][tydra] := ssi end end end end
        
        transition TransferTydraNft(
          id: String,
          tydra: String,
          token_id: ByStr32,
          to_token_id: ByStr32
          )
          IsOperational; token_id_ = builtin to_string token_id;
          get_did <-& init.did_dns[token_id_]; match get_did with
            | None => e = { _exception : "INITDAppImpl-DidIsNull" }; throw e
            | Some did_ =>
              current_controller <-& did_.controller;
              verified = builtin eq _origin current_controller; match verified with
                | True => | False => e = { _exception : "INITDAppImpl-WrongCaller" }; throw e end;
              list_part = @list_mem ByStr20; list <- tydra_free_list;
              is_participant = list_part compare_participant _origin list;
              match is_participant with
              | True =>
                list_filter = @list_filter ByStr20; remove_participant = fun( participant: ByStr20 )
                  => let is_addr = builtin eq _origin participant in negb is_addr;
                list_updated = list_filter remove_participant list;
                tydra_free_list := list_updated
              | False =>
                  txID = "TransferTydraNft";
                  get_fee <- utility[id][txID]; match get_fee with
                  | None => e = { _exception : "INITDAppImpl-FeeIsNull" }; throw e
                  | Some fee =>
                    is_zil = builtin eq id zilID; match is_zil with
                      | True =>
                        not_enough = builtin lt _amount fee; match not_enough with
                          | True => e = { _exception : "INITDAppImpl-InsufficientZIL" }; throw e
                          | False =>
                            accept; refund = builtin sub _amount fee; is_zero = builtin eq refund zero_128; match is_zero with
                            | True => | False => msg = let m = { _tag: "AddFunds"; _recipient: _sender; _amount: refund } in one_msg m; send msg end end
                      | False =>
                        get_token_addr <- services[id]; token_addr = option_bystr20_value get_token_addr;
                        dao_domain <- nft_username; get_addr <-& init.dns[dao_domain]; dao_xwallet = option_bystr20_value get_addr;
                        msg = let m = { _tag: "TransferFrom"; _recipient: token_addr; _amount: zero_128;
                          from: _sender;
                          to: dao_xwallet;
                          amount: fee } in one_msg m; send msg end end end end;
          TransferTydraToken tydra token_id to_token_id;
          e = { _eventname: "TransferTydra"; 
            from: _sender;
            to: to_token_id;
            token_id: token_id
          }; event e;
          Timestamp end
        
        procedure NftUsernameCallBack(
          username: String,
          addr: ByStr20
          )
          msg = let m = { _tag: "NftUsernameCallBack"; _recipient: init; _amount: zero_128;
          username: username;
          addr: addr } in one_msg m; send msg end
        
        procedure NftDidCallBack(
          username: String,
          dID: ByStr20
          )
          msg = let m = { _tag: "NftDidCallBack"; _recipient: init; _amount: zero_128;
            username: username;
            dID: dID } in one_msg m; send msg end
         
        procedure PremiumNftUsername_( premium: String )
          current_controller <- controller;
          get_addr <-& init.dns[premium]; match get_addr with
            | Some addr => e = { _exception : "INITDAppImpl-UsernameHasOwner" }; throw e
            | None =>
              NftUsernameCallBack premium current_controller;
              NftDidCallBack premium _this_address end end
        
        transition PremiumNftUsername( premium: List String )
          IsOperational; VerifyController;
          forall premium PremiumNftUsername_;
          Timestamp end
        
        transition BuyNftUsername(
          id: String,
          username: String,
          addr: ByStr20,
          dID: ByStr20 with contract
            field did: String,
            field nft_username: String,
            field controller: ByStr20,
            field version: String,
            field verification_methods: Map String ByStr33,
            field services: Map String ByStr20,
            field social_guardians: Map ByStr32 Bool,
            field did_domain_dns: Map String ByStr20,
            field deadline: Uint128 end
          )
          IsOperational; ThrowIfNotProxy; IsNotNull addr;
          get_ssi_addr <-& init.dns[username]; match get_ssi_addr with
            | Some addr_ => e = { _exception : "INITDAppImpl-TokenHasOwner" }; throw e
            | None =>
              list_part = @list_mem ByStr20; list <- free_list;
              is_participant = list_part compare_participant _origin list;
              match is_participant with
              | True =>
                list_filter = @list_filter ByStr20; remove_participant = fun( participant: ByStr20 )
                  => let is_addr = builtin eq _origin participant in negb is_addr;
                list_updated = list_filter remove_participant list;
                free_list := list_updated
              | False =>
                txID = "BuyNftUsername";
                get_fee <- utility[id][txID]; match get_fee with
                | None => e = { _exception : "INITDAppImpl-FeeIsNull" }; throw e
                | Some fee =>
                  is_zil = builtin eq id zilID; match is_zil with
                    | True =>
                      not_enough = builtin lt _amount fee; match not_enough with
                        | True => e = { _exception : "INITDAppImpl-InsufficientZIL" }; throw e
                        | False =>
                          accept; refund = builtin sub _amount fee; is_zero = builtin eq refund zero_128; match is_zero with
                          | True => | False => msg = let m = { _tag: "AddFunds"; _recipient: dID; _amount: refund } in one_msg m; send msg end end
                    | False =>
                      get_token_addr <- services[id]; token_addr = option_bystr20_value get_token_addr;
                      dao_domain <- nft_username; get_addr <-& init.dns[dao_domain]; dao_xwallet = option_bystr20_value get_addr;
                      msg = let m = { _tag: "TransferFrom"; _recipient: token_addr; _amount: zero_128;
                        from: dID;
                        to: dao_xwallet;
                        amount: fee } in one_msg m; send msg end end end end;
          NftUsernameCallBack username addr; NftDidCallBack username dID;
          Timestamp end
        
        transition UpdateNftDid(
          id: String,
          username: String,
          dID: ByStr20 with contract
            field did: String,
            field nft_username: String,
            field controller: ByStr20,
            field version: String,
            field verification_methods: Map String ByStr33,
            field services: Map String ByStr20,
            field social_guardians: Map ByStr32 Bool,
            field did_domain_dns: Map String ByStr20,
            field deadline: Uint128 end
          )
          IsOperational; ThrowIfNotProxy;
          get_did <-& init.did_dns[username]; match get_did with
          | Some did_ =>
            current_controller <-& did_.controller;
            verified = builtin eq _origin current_controller; match verified with
              | True => | False => e = { _exception : "INITDAppImpl-WrongCaller" }; throw e end;
            list_part = @list_mem ByStr20; list <- free_list;
            is_participant = list_part compare_participant _origin list;
            match is_participant with
            | True =>
              list_filter = @list_filter ByStr20; remove_participant = fun( participant: ByStr20 )
                => let is_addr = builtin eq _origin participant in negb is_addr;
              list_updated = list_filter remove_participant list;
              free_list := list_updated
            | False =>
              txID = "UpdateNftDid";
              get_fee <- utility[id][txID]; match get_fee with
                | None => e = { _exception : "INITDAppImpl-FeeIsNull" }; throw e
                | Some fee =>
                  is_zil = builtin eq id zilID; match is_zil with
                    | True =>
                      not_enough = builtin lt _amount fee; match not_enough with
                        | True => e = { _exception : "INITDAppImpl-InsufficientZIL" }; throw e
                        | False =>
                          accept; refund = builtin sub _amount fee; is_zero = builtin eq refund zero_128; match is_zero with
                          | True => | False => msg = let m = { _tag: "AddFunds"; _recipient: did_; _amount: refund } in one_msg m; send msg end end
                    | False =>
                      get_token_addr <- services[id]; token_addr = option_bystr20_value get_token_addr;
                      dao_domain <- nft_username; get_addr <-& init.dns[dao_domain]; dao_xwallet = option_bystr20_value get_addr;
                      msg = let m = { _tag: "TransferFrom"; _recipient: token_addr; _amount: zero_128;
                        from: did_;
                        to: dao_xwallet;
                        amount: fee } in one_msg m; send msg end end end;
            NftDidCallBack username dID
          | None => e = { _exception : "INITDAppImpl-DidIsNull" }; throw e end;
          Timestamp end
        
        transition TransferNftUsername(
          id: String,
          username: String,
          addr: ByStr20,
          dID: ByStr20 with contract
            field did: String,
            field nft_username: String,
            field controller: ByStr20,
            field version: String,
            field verification_methods: Map String ByStr33,
            field services: Map String ByStr20,
            field social_guardians: Map ByStr32 Bool,
            field did_domain_dns: Map String ByStr20,
            field deadline: Uint128 end
          )
          IsOperational; ThrowIfNotProxy; IsNotNull addr;
          get_did <-& init.did_dns[username]; match get_did with
          | Some did_ =>
            current_controller <-& did_.controller;
            verified = builtin eq _origin current_controller; match verified with
              | True => | False => e = { _exception : "INITDAppImpl-WrongCaller" }; throw e end;
            is_tydra <- exists tydras[username]; match is_tydra with
              | True => | False =>
                list_part = @list_mem ByStr20; list <- free_list;
                is_participant = list_part compare_participant _origin list;
                match is_participant with
                | True =>
                  list_filter = @list_filter ByStr20;
                  remove_participant = fun( participant: ByStr20 ) => let is_addr = builtin eq _origin participant in negb is_addr;
                  list_updated = list_filter remove_participant list;
                  free_list := list_updated
                | False =>
                  txID = "TransferNftUsername";
                  get_fee <- utility[id][txID]; match get_fee with
                    | None => e = { _exception : "INITDAppImpl-FeeIsNull" }; throw e
                    | Some fee =>
                      is_zil = builtin eq id zilID; match is_zil with
                        | True =>
                          not_enough = builtin lt _amount fee; match not_enough with
                            | True => e = { _exception : "INITDAppImpl-InsufficientZIL" }; throw e
                            | False =>
                              accept; refund = builtin sub _amount fee; is_zero = builtin eq refund zero_128; match is_zero with
                              | True => | False => msg = let m = { _tag: "AddFunds"; _recipient: did_; _amount: refund } in one_msg m; send msg end end
                        | False =>
                          get_token_addr <- services[id]; token_addr = option_bystr20_value get_token_addr;
                          dao_domain <- nft_username; get_addr <-& init.dns[dao_domain]; dao_xwallet = option_bystr20_value get_addr;
                          msg = let m = { _tag: "TransferFrom"; _recipient: token_addr; _amount: zero_128;
                            from: did_;
                            to: dao_xwallet;
                            amount: fee } in one_msg m; send msg end end end end;
            NftUsernameCallBack username addr; NftDidCallBack username dID
          | None =>
            IsClosed;
            get_addr <-& init.dns[username]; xwallet = option_bystr20_value get_addr;
            is_wallet = builtin eq xwallet addr; match is_wallet with
              | False => e = { _exception : "INITDAppImpl-WrongUpgrade" }; throw e
              | True =>
                username_ = let hash = builtin sha256hash username in builtin to_string hash; 
                NftUsernameCallBack username_ dID; NftDidCallBack username_ dID end end;
          Timestamp end