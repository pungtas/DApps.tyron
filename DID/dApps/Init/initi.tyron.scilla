(* v2.10.0
initi.tyron: SSI Initialization & DNS DApp <> Implementation smart contract
Self-Sovereign Identity Protocol
Copyright (C) Tyron Mapu Community Interest Company and its affiliates.
www.ssiprotocol.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.*)

scilla_version 0

import BoolUtils ListUtils IntUtils

library InitI
  type DidStatus =
    | Deployed
    | Created
    | Recovered
    | Updated
    | Deactivated

  type Operation =
    | Recovery
    | Update
  
  type Action =
    | Add
    | Remove

  type TransferProtocol =
    | Https
    | Git

  type BlockchainType =
    | Zilliqa of ByStr20
    | Other of String

  type Endpoint =
    | Address of BlockchainType
    | Uri of String TransferProtocol String   (* type, transfer protocol & uri *)
  
  type Document =
    | VerificationMethod of Action String ByStr33 String (* add/remove, key purpose, public key & encrypted private key *)
    | Service of Action String Endpoint (* add/remove, service ID & service *) 
  
  let didRecovery = Recovery
  let didUpdate = Update
  let update = "update"
  let recovery = "recovery"
  let actionAdd = "add"
  let actionRemove = "remove"
  let empty_methods = Emp String ByStr33
  let empty_dkms = Emp String String
  let empty_services = Emp String ByStr20
  let empty_services_ = Emp String Endpoint
  
  let one_msg = fun( msg: Message ) =>
    let nil_msg = Nil{ Message } in Cons{ Message } msg nil_msg

  type Error =
    | CodeWrongStatus
    | CodeWrongCaller
    | CodeWrongSignature
    | CodeUndefinedKey
    | CodeSameKey
    | CodeSameId
    | CodeNotValid
    | CodeSameAddress
    | CodeSameUsername
    | CodeNotProxy
    | CodeIsPaused
    | CodeNotPaused
    | CodeIsNull
    | CodeNftUsernameTaken
    | CodeInsufficientFunds
    | CodeNotEnoughChar
    
  let make_error = fun( error: Error ) =>
    let result = match error with
    | CodeWrongStatus            => Int32 0
    | CodeWrongCaller            => Int32 -1
    | CodeWrongSignature         => Int32 -2
    | CodeUndefinedKey           => Int32 -3
    | CodeSameKey                => Int32 -4
    | CodeSameId                 => Int32 -5
    | CodeNotValid               => Int32 -6
    | CodeSameAddress            => Int32 -7
    | CodeSameUsername           => Int32 -8
    | CodeNotProxy               => Int32 -9
    | CodeIsPaused               => Int32 -10
    | CodeNotPaused              => Int32 -11
    | CodeIsNull                 => Int32 -12
    | CodeNftUsernameTaken       => Int32 -13
    | CodeInsufficientFunds      => Int32 -14
    | CodeNotEnoughChar          => Int32 -15
    end in { _exception: "Error"; code: result }
  
  let zero = Uint128 0
  let zeroByStr20 = 0x0000000000000000000000000000000000000000
  let zeroByStr33 = 0x000000000000000000000000000000000000000000000000000000000000000000
  let zeroByStr64 = 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  let zeroByStr = builtin to_bystr zeroByStr20

  let option_value = 
    tfun 'A => fun( default: 'A ) => fun( input: Option 'A) => match input with
    | Some v => v
    | None => default end
  let option_bystr20_value = let f = @option_value ByStr20 in f zeroByStr20
  let option_bystr33_value = let f = @option_value ByStr33 in f zeroByStr33
  let option_bystr64_value = let f = @option_value ByStr64 in f zeroByStr64

  let zero_ = Uint32 0
  let six = Uint32 6
  
  type Beneficiary =
    | NftUsername of String
    | Recipient of ByStr20
    
  let true = True
  let false = False
  let tyron_id = "tyron0"
  let ssi_id = "$si000"
  let tyron_addr = 0x9df88becdcc0752038446ba0eccab221c22b8136 (* test/ @todo *)
  let ssi_addr = 0xb8dc094ad8e34d4bec3076afa8bd52a3e73f8221
  
  let compare_participant = fun( addr: ByStr20 ) => fun( participant: ByStr20 ) => builtin eq addr participant
  
contract InitI(
  init_username: String,
  init: ByStr20 with contract
    field dns: Map String ByStr20,
    field did_dns: Map String ByStr20 with contract
      field did: String,   (* the W3C decentralized identifier *)
      field nft_username: String,
      field controller: ByStr20,
      field version: String,
      field verification_methods: Map String ByStr33,
      field services: Map String ByStr20,
      field did_domain_dns: Map String ByStr20 end end
  )
  field did: String = ""    (* the W3C decentralized identifier *)
  field nft_username: String = init_username
  field pending_username: String = ""
  field controller: ByStr20 = zeroByStr20
  field did_status: DidStatus = Deployed
  field version: String = "initi---2.10.0" (* @todo *)
  
  (* Verification methods @key: key purpose @value: public DID key *)
  field verification_methods: Map String ByStr33 = empty_methods
  field dkms: Map String String = empty_dkms
  
  (* Services @key: ID @value: endpoint *)
  field services: Map String ByStr20 = let emp = Emp String ByStr20 in
    let m = builtin put emp tyron_id tyron_addr in builtin put m ssi_id ssi_addr
  field services_: Map String Endpoint = empty_services_
  
  field did_domain_dns: Map String ByStr20 = Emp String ByStr20

  field did_hash: ByStr = zeroByStr
  
  (* The block number when the DID Create operation occurred *)
  field did_created: BNum = BNum 0
  
  (* The block number when the last DID CRUD operation occurred *)  
  field ledger_time: BNum = BNum 0
  
  (* A monotonically increasing number representing the amount of DID CRUD transactions that have taken place *)
  field tx_number: Uint128 = zero
  
  field paused: Bool = False

  field utility: Map String Uint128 = let emp = Emp String Uint128 in
    let ten = Uint128 10000000000000 in let m = builtin put emp ssi_id ten in
    builtin put m tyron_id ten
  
  field minchar: Uint32 = Uint32 6

  field free_list: List ByStr20 = Nil{ ByStr20 }

procedure SupportTyron( tyron: Option Uint128 )
  match tyron with
  | None => | Some donation =>
      donateDApp = "donate"; get_addr <-& init.dns[donateDApp]; addr = option_bystr20_value get_addr;
      accept; msg = let m = { _tag: "AddFunds"; _recipient: addr; _amount: donation } in one_msg m; send msg end end

procedure ThrowError( err: Error )
  e = make_error err; throw e end

procedure IsOperational()
  current_status <- did_status; match current_status with
  | Deactivated => err = CodeWrongStatus; ThrowError err
  | _ => end end

procedure VerifyController( tyron: Option Uint128 )
  current_username <- nft_username;
  get_did <-& init.did_dns[current_username]; match get_did with
  | None => err = CodeIsNull; ThrowError err
  | Some did_ =>
      current_controller <-& did_.controller;
      verified = builtin eq _origin current_controller; match verified with
      | True => | False => err = CodeWrongCaller; ThrowError err end;
      SupportTyron tyron; controller := current_controller end end

procedure Timestamp()
  current_block <- &BLOCKNUMBER; ledger_time := current_block;
  latest_tx_number <- tx_number;
  new_tx_number = let incrementor = Uint128 1 in builtin add latest_tx_number incrementor; tx_number := new_tx_number end

procedure ThrowIfSameAddr(
  a: ByStr20,
  b: ByStr20
  )
  is_same = builtin eq a b; match is_same with
  | False => | True => err = CodeSameAddress; ThrowError err end end

procedure ThrowIfSameName(
  a: String,
  b: String
  )
  is_same = builtin eq a b; match is_same with
  | False => | True => err = CodeSameUsername; ThrowError err end end

transition UpdateUsername(
  username: String,
  tyron: Option Uint128
  )
  IsOperational; VerifyController tyron;
  current_username <- nft_username; ThrowIfSameName current_username username;
  get_did <-& init.did_dns[username]; match get_did with
  | None => err = CodeIsNull; ThrowError err
  | Some did_ => pending_username := username; Timestamp end end

transition AcceptPendingUsername()
  IsOperational; current_pending <- pending_username;
  get_did <-& init.did_dns[current_pending]; match get_did with
  | None => err = CodeIsNull; ThrowError err
  | Some did_ =>
      current_controller <-& did_.controller;
      verified = builtin eq _origin current_controller; match verified with
      | True => | False => err = CodeWrongCaller; ThrowError err end;
      nft_username := current_pending end end

(* Verify Schnorr signature - signed data must correspond with a DID key *)
procedure VerifySignature(
  id: String,
  signedData: ByStr,
  signature: ByStr64
  )
  get_did_key <- verification_methods[id]; did_key = option_bystr33_value get_did_key;
  is_right_signature = builtin schnorr_verify did_key signedData signature; match is_right_signature with
  | True => | False => err = CodeWrongSignature; ThrowError err end end

procedure ThrowIfNoKey( optKey: Option ByStr33 )
  match optKey with
  | Some key =>
  | None => err = CodeUndefinedKey; ThrowError err end end

procedure ThrowIfSameKey(
  key: ByStr33,
  sndKey: ByStr33
  )
  is_same_key = builtin eq key sndKey;
  match is_same_key with
  | True => err = CodeSameKey; ThrowError err
  | False => end end

procedure VerifyDidkeys(
  operation: Operation,
  didRecovery: ByStr33,
  didUpdate: ByStr33
  )
  get_update_key <- verification_methods[update]; new_update = option_bystr33_value get_update_key;
  ThrowIfSameKey new_update didUpdate; ThrowIfSameKey new_update didRecovery;
  match operation with
  | Update => | Recovery =>
    get_recovery_key <- verification_methods[recovery]; new_recovery = option_bystr33_value get_recovery_key;
    ThrowIfSameKey new_recovery new_update;
    ThrowIfSameKey new_recovery didRecovery; ThrowIfSameKey new_recovery didUpdate end end

procedure SaveDocument( document: Document )
  match document with
  | VerificationMethod action purpose key encrypted =>
      key_exists <- exists verification_methods[purpose];
      match action with
      | Add =>
          match key_exists with
          | True => err = CodeSameId; ThrowError err
          | False =>
              verification_methods[purpose] := key;
              dkms[purpose] := encrypted end
      | Remove => err = CodeNotValid; ThrowError err end
  | Service action id endpoint =>
      is_service <- exists services[id];
      is_service_ <- exists services_[id];
      service_exists = orb is_service is_service_;
      match action with
      | Add =>
          match service_exists with
          | True => err = CodeSameId; ThrowError err
          | False =>
              match endpoint with
              | Address address =>
                 match address with
                   | Zilliqa addr => services[id] := addr
                   | Other adrr => services_[id] := endpoint end
              | Uri eType protocol uri => services_[id] := endpoint end end
      | Remove => err = CodeNotValid; ThrowError err end end end

transition DidCreate(
  document: List Document,
  signature: Option ByStr64,
  tyron: Option Uint128
  )
  current_status <- did_status; match current_status with
  | Deployed =>
      VerifyController tyron;
      new_did = let did_prefix = "did:tyron:zil:main:" in let did_suffix = builtin to_string _this_address in
      builtin concat did_prefix did_suffix; did := new_did;
      forall document SaveDocument;
      get_recovery_key <- verification_methods[recovery]; ThrowIfNoKey get_recovery_key; did_recovery = option_bystr33_value get_recovery_key;
      get_update_key <- verification_methods[update]; ThrowIfNoKey get_update_key; did_update = option_bystr33_value get_update_key;
      ThrowIfSameKey did_recovery did_update;
      new_status = Created; did_status := new_status;
      current_block <- &BLOCKNUMBER; did_created := current_block; Timestamp
  | _ => err = CodeWrongStatus; ThrowError err end end

procedure UpdateDocument( document: Document )
  match document with
  | VerificationMethod action purpose key encrypted =>
      match action with
      | Add =>
          verification_methods[purpose] := key;
          dkms[purpose] := encrypted
      | Remove =>
          key_exists <- exists verification_methods[purpose];
          match key_exists with
          | True =>
              delete verification_methods[purpose];
              delete dkms[purpose]
          | False => err = CodeNotValid; ThrowError err end end
  | Service action id endpoint =>
      is_service <- exists services[id];
      is_service_ <- exists services_[id];
      service_exists = orb is_service is_service_;
      match action with
      | Add =>
          match service_exists with
          | True => err = CodeSameId; ThrowError err
          | False => 
              match endpoint with
              | Address address =>
               match address with
                 | Zilliqa addr => services[id] := addr
                 | Other adrr => services_[id] := endpoint end
              | Uri eType protocol uri => services_[id] := endpoint end end
      | Remove =>
          match service_exists with
          | True => delete services[id]; delete services_[id]
          | False => err = CodeNotValid; ThrowError err end end end end

procedure HashDocument( document: Document )
  doc_hash <- did_hash;
  match document with
  | VerificationMethod action purpose key encrypted =>
      match action with
      | Add =>
          hash = let h1 = builtin sha256hash actionAdd in
            let h2 = builtin sha256hash purpose in
            let h3 = builtin sha256hash key in
            let h4 = builtin sha256hash encrypted in
            let h1_2 = builtin concat h1 h2 in
            let h1_3 = builtin concat h1_2 h3 in
            builtin concat h1_3 h4;
          doc_hash_ = let hash_ = builtin to_bystr hash in builtin concat doc_hash hash_;
          did_hash := doc_hash_
      | Remove =>
          hash = let h1 = builtin sha256hash actionRemove in
            let h2 = builtin sha256hash purpose in
            builtin concat h1 h2;
          doc_hash_ = let hash_ = builtin to_bystr hash in builtin concat doc_hash hash_;
          did_hash := doc_hash_ end
  | Service action id endpoint =>
      match action with
      | Add =>
          match endpoint with
          | Uri eType transfer uri =>
              hash = let h1 = builtin sha256hash actionAdd in
                let h2 = builtin sha256hash id in
                let h3 = builtin sha256hash uri in
                let h1_2 = builtin concat h1 h2 in
                builtin concat h1_2 h3;
              doc_hash_ = let hash_ = builtin to_bystr hash in builtin concat doc_hash hash_;
              did_hash := doc_hash_
          | Address address =>
              hash = match address with
                      | Zilliqa addr =>
                          let h1 = builtin sha256hash actionAdd in
                          let h2 = builtin sha256hash id in
                          let h3 = builtin sha256hash addr in
                          let h1_2 = builtin concat h1 h2 in
                          builtin concat h1_2 h3
                      | Other addr =>
                          let h1 = builtin sha256hash actionAdd in
                          let h2 = builtin sha256hash id in
                          let h3 = builtin sha256hash addr in
                          let h1_2 = builtin concat h1 h2 in
                          builtin concat h1_2 h3 end;
              doc_hash_ = let hash_ = builtin to_bystr hash in builtin concat doc_hash hash_;
              did_hash := doc_hash_ end
      | Remove =>
          hash = let h1 = builtin sha256hash actionRemove in
            let h2 = builtin sha256hash id in
            builtin concat h1 h2;
          doc_hash_ = let hash_ = builtin to_bystr hash in builtin concat doc_hash hash_;
          did_hash := doc_hash_ end end end
          
procedure ValidateDocument(
  operation: Operation,
  document: List Document
  )
  match operation with
  | Recovery => 
      verification_methods := empty_methods; dkms := empty_dkms; services := empty_services; services_ := empty_services_;
      forall document SaveDocument
  | Update => forall document UpdateDocument end end

procedure VerifyDocument(
  operation: Operation,
  document: List Document,
  signature: Option ByStr64
  )
  did_hash := zeroByStr;
  forall document HashDocument; doc_hash <- did_hash;
  sig = option_bystr64_value signature;
  id = match operation with
  | Recovery => recovery
  | Update => update end; VerifySignature id doc_hash sig;
  ValidateDocument operation document end

transition DidRecover(
  document: List Document,
  signature: Option ByStr64,
  tyron: Option Uint128
  )
  VerifyController tyron;
  current_status <- did_status; match current_status with
  | Created => | Recovered => | Updated =>
      get_recovery_key <- verification_methods[recovery]; did_recovery = option_bystr33_value get_recovery_key;
      get_update_key <- verification_methods[update]; did_update = option_bystr33_value get_update_key;
      VerifyDocument didRecovery document signature;
      VerifyDidkeys didRecovery did_recovery did_update
  | _ => err = CodeWrongStatus; ThrowError err end;
  new_status = Recovered; did_status := new_status; Timestamp end

transition DidUpdate(
  document: List Document,
  signature: Option ByStr64,
  tyron: Option Uint128
  )
  current_status <- did_status; match current_status with
  | Created => | Recovered => | Updated =>
  | _ => err = CodeWrongStatus; ThrowError err end;
  VerifyController tyron;
  get_recovery_key <- verification_methods[recovery]; did_recovery = option_bystr33_value get_recovery_key;
  get_update_key <- verification_methods[update]; did_update = option_bystr33_value get_update_key;
  VerifyDocument didUpdate document signature;
  VerifyDidkeys didUpdate did_recovery did_update;
  new_status = Updated; did_status := new_status; Timestamp end

transition DidDeactivate(
  document: List Document,
  signature: Option ByStr64,
  tyron: Option Uint128
  ) 
  IsOperational; VerifyController tyron;
  VerifyDocument didRecovery document signature;
  verification_methods := empty_methods; services := empty_services; services_ := empty_services_;
  new_status = Deactivated; did_status := new_status; Timestamp end

transition Dns(
  addr: ByStr20,
  domain: String,
  didKey: ByStr33,
  encrypted: String,
  tyron: Option Uint128
  )
  current_status <- did_status; match current_status with
  | Created => | Recovered => | Updated =>
  | _ => err = CodeWrongStatus; ThrowError err end;
  VerifyController tyron; ThrowIfSameAddr _this_address addr;
  verification_methods[domain] := didKey; dkms[domain] := encrypted; did_domain_dns[domain] := addr; 
  new_status = Updated; did_status := new_status; Timestamp end

(* Wallet backbone *)

(* Receive $ZIL native funds *)
transition AddFunds()
  IsOperational; accept; Timestamp end

(* Send $ZIL to any recipient that implements the tag, e.g. "AddFunds", "", etc. *)
transition SendFunds(
  tag: String,
  beneficiary: Beneficiary,
  amount: Uint128,
  tyron: Option Uint128
  )
  IsOperational; VerifyController tyron;
  match beneficiary with
  | NftUsername username =>
      get_addr <-& init.dns[username]; addr = option_bystr20_value get_addr; ThrowIfSameAddr _this_address addr;
      msg = let m = { _tag: tag; _recipient: addr; _amount: amount } in one_msg m; send msg
  | Recipient addr =>
      ThrowIfSameAddr _this_address addr;
      msg = let m = { _tag: tag; _recipient: addr; _amount: amount } in one_msg m; send msg end; Timestamp end

transition Transfer(
  addrName: String,
  beneficiary: Beneficiary,
  amount: Uint128,
  tyron: Option Uint128
  ) 
  IsOperational; VerifyController tyron;
  get_token_addr <- services[addrName]; token_addr = option_bystr20_value get_token_addr;
  match beneficiary with
  | NftUsername username =>
      get_addr <-& init.dns[username]; addr = option_bystr20_value get_addr; ThrowIfSameAddr _this_address addr;
      msg = let m = { _tag: "Transfer"; _recipient: token_addr; _amount: zero;
        to: addr;
        amount: amount } in one_msg m ; send msg
  | Recipient addr =>
      ThrowIfSameAddr _this_address addr;
      msg = let m = { _tag: "Transfer"; _recipient: token_addr; _amount: zero;
        to: addr;
        amount: amount } in one_msg m ; send msg end; Timestamp end

transition RecipientAcceptTransfer( sender: ByStr20, recipient: ByStr20, amount: Uint128 ) IsOperational end

transition RecipientAcceptTransferFrom( initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128 ) IsOperational end

transition TransferSuccessCallBack( sender: ByStr20, recipient: ByStr20, amount : Uint128 ) IsOperational end

transition TransferFromSuccessCallBack( initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128 ) IsOperational end

(* Init implementation backbone *)

procedure ThrowIfNotProxy()
  verified = builtin eq init _sender; match verified with
  | True => | False => err= CodeNotProxy; ThrowError err end end

procedure IsNotPaused()
  is_paused <- paused; match is_paused with
  | False => | True => err = CodeIsPaused; ThrowError err end end

procedure IsPaused()
  is_paused <- paused; match is_paused with
  | True => | False => err = CodeNotPaused; ThrowError err end end

procedure IsNotNull( addr: ByStr20 )
  is_null = builtin eq addr zeroByStr20; match is_null with
  | False => | True => err = CodeIsNull; ThrowError err end end

transition Pause( tyron: Option Uint128 )
  IsOperational; VerifyController tyron; IsNotPaused; paused := true;
  e = { _eventname: "SmartContractPaused";
    pauser: _origin }; event e end

transition Unpause( tyron: Option Uint128 )
  IsOperational; VerifyController tyron; IsPaused; paused := false;
  e = { _eventname: "SmartContractUnpaused";
    pauser: _origin }; event e end

transition AddUtility(
  id: String,
  fee: Uint128,
  tyron: Option Uint128
  )
  IsOperational; IsNotPaused; VerifyController tyron; utility[id] := fee end
  
transition RemoveUtility(
  id: String,
  tyron: Option Uint128
  )
  IsOperational; IsNotPaused; VerifyController tyron; delete utility[id] end

procedure NftUsernameCallBack(
  username: String,
  addr: ByStr20
  )
  msg = let m = { _tag: "NftUsernameCallBack"; _recipient: init; _amount: zero;
    username: username;
    addr: addr } in one_msg m; send msg end
  
procedure PremiumNftUsername_( premium: String )
  current_controller <- controller;
  get_addr <-& init.dns[premium]; match get_addr with
  | Some addr => err = CodeNftUsernameTaken; ThrowError err
  | None => NftUsernameCallBack premium current_controller end end

transition PremiumNftUsername(
  premium: List String,
  tyron: Option Uint128
  )
  IsOperational; IsNotPaused; VerifyController tyron;
  forall premium PremiumNftUsername_ end

procedure NftDidCallBack(
  username: String,
  did_: ByStr20 with contract
    field did: String,
    field nft_username: String,
    field controller: ByStr20,
    field did_status: DidStatus,
    field version: String,
    field verification_methods: Map String ByStr33,
    field services: Map String ByStr20,
    field did_domain_dns: Map String ByStr20 end
  )
  msg = let m = { _tag: "NftDidCallBack"; _recipient: init; _amount: zero;
    username: username;
    did_: did_ } in one_msg m; send msg end

transition UpdateMinChar(
  val: Uint32,
  tyron: Option Uint128
  )
  IsOperational; IsNotPaused; VerifyController tyron; minchar := val end

procedure VerifyMinChar( username: String )
  length = builtin strlen username; current_minchar <- minchar;
  verified = uint32_ge length current_minchar; match verified with
  | True => | False => err = CodeNotEnoughChar; ThrowError err end end
  
procedure UpdateFreeList_( addr: ByStr20 )
  list <- free_list;
  list_updated = Cons{ ByStr20 } addr list;
  free_list := list_updated end

transition UpdateFreeList(
  val: List ByStr20,
  tyron: Option Uint128
  )
  IsOperational; IsNotPaused; VerifyController tyron;
  forall val UpdateFreeList_ end

transition BuyNftUsername(
  username: String,
  addr: ByStr20,
  dID: Option ByStr20 with contract
    field did: String,
    field nft_username: String,
    field controller: ByStr20,
    field did_status: DidStatus,
    field version: String,
    field verification_methods: Map String ByStr33,
    field services: Map String ByStr20,
    field did_domain_dns: Map String ByStr20 end
  )
  IsOperational; ThrowIfNotProxy; IsNotPaused; IsNotNull addr; VerifyMinChar username;
  get_addr <-& init.dns[username]; match get_addr with
  | Some addr_ => err = CodeNftUsernameTaken; ThrowError err
  | None =>
      list_part = @list_mem ByStr20; list <- free_list;
      is_participant = list_part compare_participant _origin list;
      match is_participant with
      | True =>
          list_filter = @list_filter ByStr20; remove_participant = fun( participant: ByStr20 ) => let is_addr = builtin eq _origin participant in negb is_addr;
          list_updated = list_filter remove_participant list;
          free_list := list_updated
      | False =>
          id = builtin substr username zero_ six;
          get_fee <- utility[id]; match get_fee with
          | None => err = CodeIsNull; ThrowError err
          | Some fee =>
              get_token_addr <- services[id]; token_addr = option_bystr20_value get_token_addr;
              msg = let m = { _tag: "TransferFrom"; _recipient: token_addr; _amount: zero;
                from: addr;
                to: _this_address;
                amount: fee } in one_msg m; send msg end end end;
  username_ = let total_len = builtin strlen username in let len = builtin sub total_len six in
    builtin substr username six len;
  NftUsernameCallBack username_ addr;
  match dID with
  | None => | Some did_ => NftDidCallBack username_ did_ end end

transition UpdateNftDid(
  username: String,
  addr: ByStr20,
  dID: ByStr20 with contract
    field did: String,
    field nft_username: String,
    field controller: ByStr20,
    field did_status: DidStatus,
    field version: String,
    field verification_methods: Map String ByStr33,
    field services: Map String ByStr20,
    field did_domain_dns: Map String ByStr20 end
  )
  IsOperational; ThrowIfNotProxy; IsNotPaused;
  get_addr <-& init.dns[username]; match get_addr with
  | Some addr_ =>
      is_owner = builtin eq addr addr_;
      match is_owner with
      | False => err = CodeWrongCaller; ThrowError err
      | True => NftDidCallBack username dID end
  | None => err = CodeIsNull; ThrowError err end end

transition TransferNftUsername(
  username: String,
  addr: ByStr20,
  newAddr: ByStr20,
  dID: Option ByStr20 with contract
    field did: String,
    field nft_username: String,
    field controller: ByStr20,
    field did_status: DidStatus,
    field version: String,
    field verification_methods: Map String ByStr33,
    field services: Map String ByStr20,
    field did_domain_dns: Map String ByStr20 end
  )
  IsOperational; ThrowIfNotProxy; IsNotPaused; IsNotNull newAddr;
  get_addr <-& init.dns[username]; addr_ = option_bystr20_value get_addr;
  is_owner = builtin eq addr addr_;
  match is_owner with
  | False => err = CodeWrongCaller; ThrowError err
  | True =>
      list_part = @list_mem ByStr20; list <- free_list;
      is_participant = list_part compare_participant _origin list;
      match is_participant with
      | True =>
          list_filter = @list_filter ByStr20;
          remove_participant = fun( participant: ByStr20 ) => let is_addr = builtin eq _origin participant in negb is_addr;
          list_updated = list_filter remove_participant list;
          free_list := list_updated
      | False =>
          id = builtin substr username zero_ six;
          get_fee <- utility[id]; match get_fee with
          | None => err = CodeIsNull; ThrowError err
          | Some fee =>
              get_token_addr <- services[id]; token_addr = option_bystr20_value get_token_addr;
              msg = let m = { _tag: "TransferFrom"; _recipient: token_addr; _amount: zero;
                from: addr;
                to: _this_address;
                amount: fee } in one_msg m; send msg end end end;
  username_ = let total_len = builtin strlen username in let len = builtin sub total_len six in
    builtin substr username six len;
  NftUsernameCallBack username_ newAddr;
  match dID with
  | Some did_ => NftDidCallBack username_ did_
  | None =>
      msg = let m = { _tag: "RemoveNftDidCallBack"; _recipient: _sender; _amount: zero;
        username: username_ } in one_msg m; send msg end end