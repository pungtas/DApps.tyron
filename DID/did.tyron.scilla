(*
  DID.tyron: decentralized identifier smart contract.
  Self-Sovereign Identity Protocol.
  Copyright (C) Tyron Pungtas and its affiliates.

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
*)

scilla_version 0

library DID

  type DIDstatus =
    | Deployed
    | Created
    | Updated
    | Recovered
    | Deactivated

  type Operation =
    | Recovery
    | Update
    | Tyron of String

  let one_msg = fun( msg: Message ) =>
    let nil_msg = Nil{ Message } in Cons{ Message } msg nil_msg

  let two_msgs = fun( msg1: Message ) => fun( msg2: Message ) =>
    let msgs_tmp = one_msg msg2 in Cons{ Message } msg1 msgs_tmp

  type Error =
    | CodeWrongStatus
    | CodeNotOwner
    | CodeWrongSignature
    | CodeUndefinedKey
    | ThrownIfSameKey
    | CodeNotValid

  let make_error = fun( error: Error ) =>
    let result = match error with
    | CodeWrongStatus            => Int32 -1
    | CodeNotOwner               => Int32 -2
    | CodeWrongSignature         => Int32 -3
    | CodeUndefinedKey           => Int32 -4
    | ThrownIfSameKey            => Int32 -5
    | CodeNotValid               => Int32 -6
    end in { _exception: "Error"; code: result }
  
  let recovery = Recovery
  let update = Update
  
  let option_value = tfun 'A => fun( default: 'A ) => fun( input: Option 'A) =>
    match input with
    | Some v => v
    | None => default
    end

  let zero = Uint128 0
  let zeroByStr20 = 0x0000000000000000000000000000000000000000
  let zeroByStr33 = 0x000000000000000000000000000000000000000000000000000000000000000000
  let zeroByStr64 = 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  let option_uint128_value = let f = @option_value Uint128 in f zero
  let option_bystr20_value = let f = @option_value ByStr20 in f zeroByStr20  
  let option_bystr33_value = let f = @option_value ByStr33 in f zeroByStr33
  let option_bystr64_value = let f = @option_value ByStr64 in f zeroByStr64


  type Action =
    | Add
    | Remove

  type TransferProtocol =
    | Https
    | Git
    | Zilliqa
    | Arweave

  type ServiceEndpoint =
    | ServiceEndpoint of TransferProtocol String
    
  type DidService =
    | DidService of String ServiceEndpoint  (* the type & endpoint *)
    
  type Document =
    | VerificationMethod of Action String ByStr33  (* string: key purpose OR service ID *)
    | Service of Action String DidService
    
  let update_methods: forall 'A. List Document -> Map String ByStr33 -> Map String ByStr33 = tfun 'A => fun(l: List Document) => fun(prevMethods: Map String ByStr33) =>
    let foldl = @list_foldl Document Map String ByStr33
    in let iter = fun(map: Map String ByStr33) => fun(h: Document) =>
      match h with
      | VerificationMethod action purpose key =>
          match action with
            | Add =>
                builtin put map purpose key
            | Remove =>
                builtin remove map purpose
          end
      | _ => map
      end in foldl iter prevMethods l

  let make_endpoint = fun( input: DidService ) =>
    match input with
    | DidService tipo endpoint =>
        match endpoint with
        | ServiceEndpoint transfer addr =>
            match transfer
            | Https =>
                let prefix = "https://" in let uri = builtin concat prefix addr in
                Pair{ String String } tipo uri
            | Git =>
                let prefix = "git://" in let uri = builtin concat prefix addr in
                Pair{String String} tipo uri
            | Zilliqa =>
                let prefix = "zil://" in let uri = builtin concat prefix addr in
                Pair{ String String } tipo uri
            | Arweave =>
                let prefix = "ar://" in let uri = builtin concat prefix addr in
                Pair{ String String } tipo uri
            end
        end
    end

  let update_services: forall 'A. List Document -> Map String Pair String String -> Map String Pair String String = tfun 'A => fun( l: List Document ) => fun( prevServices: Map String Pair String String ) =>
    let foldl = @list_foldl Document Map String Pair String String
    in let iter = fun( map: Map String Pair String String ) => fun( h: Document ) =>
      match h with
      | Service action id didService =>
          match action with
          | Add =>
              let endpoint = make_endpoint didService
              in builtin put map id endpoint
          | Remove =>
              builtin remove map id
          end
      | _ => map
      end in foldl iter prevServices l
    
contract DID(
  initOwner: ByStr20, (* the Zilliqa address of the DID owner *)
  init_tyron: ByStr20 (* the init.tyron smart contract *)
  )

  field did: String = "" (* the decentralized identifier *)
  field did_status: DIDstatus = Deployed
  
  field owner: ByStr20 = initOwner

  (* Verification methods
  @key: key purpose
  @value: public key of type "SchnorrSecp256k1VerificationKey2019" *)
  field verification_methods: Map String ByStr33 = Emp String ByStr33
  
  (* Services
  @key: ID
  @value: the type & URI *)
  field services: Map String Pair String String = Emp String Pair String String
  
  (* The public key for the next DID Update operation *)
  field did_update_key: Option ByStr33 = None{ ByStr33 }
  
  (* The public key for the next DID Recover or Deactivate operation *)
  field did_recovery_key: Option ByStr33 = None{ ByStr33 }
  
  (* The block number when the DID Create operation occurred *)
  field created: BNum = BNum 0
  
  (* The block number when the last DID operation occurred *)  
  field ledger_time: BNum = BNum 0
  
  (* A monotonically increasing number representing the amount of DID operations that have taken place *)
  field transaction_number: Uint128 = Uint128 0
  
  field records: Map ByStr20 ByStr20 = Emp ByStr20 ByStr20

procedure ThrowError(
  err: Error
  )
  e = make_error err; throw e
end

procedure VerifyOwner()
  current_owner <- owner;
  is_owner = builtin eq current_owner _sender;
  match is_owner with
  | True =>
  | False => err= CodeNotOwner; ThrowError err
  end
end

(* Verifies that the DID is operational *)
procedure IsOperational()
  this_status <- did_status;
  match this_status with
  | Deactivated => err= CodeWrongStatus; ThrowError err
  | _ =>
  end
end
  
procedure ThrowIfNoKey(
  optKey: Option ByStr33
  )
  match optKey with
  | Some key =>
  | None => err = CodeUndefinedKey; ThrowError err
  end
end

procedure ThrowIfSameKey(
  key1: ByStr33,
  key2: ByStr33
  )
  is_same_key = builtin eq key1 key2;
  match is_same_key with
  | True => err= ThrownIfSameKey; ThrowError err
  | False =>
  end
end

procedure VerifyDIDkeys(
  operation: Operation,
  recoveryKey: Option ByStr33,
  updateKey: Option ByStr33
  )
  get_recovery_key <- did_recovery_key; did_recovery = option_bystr33_value get_recovery_key;
  get_update_key <- did_update_key; did_update = option_bystr33_value get_update_key;
  match operation with
  | Recovery =>
      ThrowIfNoKey recoveryKey; ThrowIfNoKey updateKey;
      recovery_key = option_bystr33_value recoveryKey; update_key = option_bystr33_value updateKey;
      ThrowIfSameKey recovery_key update_key; ThrowIfSameKey did_recovery recovery_key; ThrowIfSameKey did_recovery update_key; ThrowIfSameKey did_update recovery_key; ThrowIfSameKey did_update update_key;
      did_recovery_key := recoveryKey; did_update_key := updateKey
  | Update =>
      ThrowIfNoKey updateKey;
      update_key = option_bystr33_value updateKey;
      ThrowIfSameKey did_update update_key; ThrowIfSameKey did_recovery update_key;
      did_update_key := updateKey
  | _ => (* upgrade verification of tyron key *)
  end
end

(* Verify Schnorr signature - signed data must correspond with a DID Key *)
procedure VerifySignature(
  operation: Operation,
  signedData: ByStr,
  signature: Option ByStr64
  )
  sig = option_bystr64_value signature;
  match operation with
  | Recovery =>
      get_recovery_key <- did_recovery_key;
      did_recovery = option_bystr33_value get_recovery_key;
      signature_is_right = builtin schnorr_verify did_recovery signedData sig;
      correct_signature := signature_is_right
  | Update =>
      get_update_key <- did_update_key;
      did_update = option_bystr33_value get_update_key;
      signature_is_right = builtin schnorr_verify did_update signedData sig;
      correct_signature := signature_is_right
  | Tyron keyId =>
      get_key <- verification_methods[keyId]; key = option_bystr33_value get_key;
      signature_is_right = builtin schnorr_verify key signedData sig;
      correct_signature := signature_is_right
  end;
  signature_verified <- correct_signature;
  match signature_verified with
    | True =>
    | False => err= CodeWrongSignature; ThrowError err
  end;
  false = False; correct_signature := false
end

(* Update verification methods and services *)
procedure UpdateDocument(
  operation: Operation,
  document: List Document
  )
  current_methods <- verification_methods; current_services <- services;
  prev_methods = match operation with
  | Recovery => Emp String ByStr33
  | _ => current_methods
  end;
  update_methods = @update_methods Document; update_services = @update_services Document;
  updated_methods = update_methods document prev_methods; verification_methods := updated_methods;
  prev_services = match operation with
  | Recovery => Emp String Pair String String
  | _ => current_services
  end;
  updated_services = update_services document prev_services; services := updated_services
end

procedure Timestamp()
  current_block <- &BLOCKNUMBER; ledger_time := current_block;
  latest_tx_number <- transaction_number;
  new_tx_number =
    let incrementor = Uint128 1 in builtin add latest_tx_number incrementor;
  transaction_number := new_tx_number
end

procedure SetDomain(
  domain: String
  )
  current_owner <- owner;
  msg = let m = {
		_tag: "SetDidDomain";
		_recipient: current_owner;
		_amount: zero;
		domain: domain
	} in one_msg m; send msg
end

transition UpdateOwner(
  addr: ByStr20
  )
  VerifyOwner;
  owner := addr
end

transition DIDcreate(
  recoveryKey: Option ByStr33,
  updateKey: Option ByStr33,
  document: Option (List Document),
  signedData: Option ByStr,
  signature: Option ByStr64,
  domain: String
  )
  VerifyOwner; IsOperational;
  this_did =
    let did_prefix = "did:tyron:zil:test:"
    in let did_suffix = builtin to_string _this_address in builtin concat did_prefix did_suffix;
  did := this_did;
  VerifyDIDkeys recovery recoveryKey updateKey;
  match document with
  | None => err= CodeNotValid; ThrowError err
  | Some doc =>
      UpdateDocument recovery doc;
      new_status = Created;
      did_status := new_status;
      current_block <- &BLOCKNUMBER;
      created := current_block;
      Timestamp
  end;
  SetDomain domain
end

transition DIDrecover(
  recoveryKey: Option ByStr33,
  updateKey: Option ByStr33,
  document: Option (List Document),
  signedData: ByStr,
  signature: Option ByStr64
  )
  VerifyOwner; IsOperational;
  VerifyDIDkeys recovery recoveryKey updateKey;
  match document with
  | None => err= CodeNotValid; ThrowError err
  | Some doc =>
      IsRightSignature recovery signedData signature;
      UpdateDocument recovery doc;
      new_status = Recovered;
      did_status := new_status;
      Timestamp
  end
end

transition DIDupdate(
  recoveryKey: Option ByStr33,
  updateKey: Option ByStr33,
  document: Option (List Document),
  signedData: ByStr,
  signature: Option ByStr64
  )
  VerifyOwner; IsOperational;
  VerifyDIDkeys update recoveryKey updateKey;
  match document with
  | None => err= CodeNotValid; ThrowError err
  | Some doc =>
      IsRightSignature update signedData signature;
      UpdateDocument update doc;
      new_status = Updated;
      did_status := new_status;
      Timestamp
  end
end

transition DIDdeactivate(
  signedData: ByStr,
  signature: Option ByStr64
  ) 
  VerifyOwner; IsOperational;
  IsRightSignature recovery signedData signature;
  deactivated_key = None{ByStr33};
  did_update_key := deactivated_key;
  did_recovery_key := deactivated_key;
  deactivated_methods = Emp String ByStr33; verification_methods := deactivated_methods;
  deactivated_services = Emp String Pair String String; services := deactivated_services;
  new_status = Deactivated; did_status := new_status;
  Timestamp
end

(* Receive native funds ($ZIL) and send them to the SSI *)
transition AddFunds()
  IsOperational; accept;
  e = {
    _eventname: "ZILreceived";
    sender: _sender;
    amount: _amount
  }; event e;
  current_owner <- owner;
  msg = let m = {
    _tag: "AddFunds";
    _recipient: current_owner;
    _amount: _amount
  } in one_msg m; send msg
end

procedure VerifyRecord()
  current_owner <- owner;
  accept;
  msg = let m = {
    _tag: "VerifyRecord";
    _recipient: current_owner;
    _amount: _amount;
    sender: _sender
  } in one_msg m ; send msg 
end

transition VerifyRecordCallBack(
  implAddr: ByStr20,
  proxyAddr: ByStr20
  )
  VerifyOwner;
  records[implAddr] := proxyAddr
end

transition RecipientAcceptTransfer(
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
  )
  IsOperational;
  e = {
    _eventname: "TransferReceived";
    token: _sender;
    sender: sender;
    amount: amount
  }; event e;
  current_owner <- owner;
  VerifyRecord;
  get_proxy_addr <- records[_sender]; proxy_addr = option_bystr20_value get_proxy_addr;
  msg = let m = {
    _tag: "Transfer";
    _recipient: proxy_addr;
    _amount: zero;
    to: current_owner;
    amount: amount
  } in one_msg m ; send msg 
end

transition TransferSuccessCallBack(
  sender: ByStr20, 
  recipient: ByStr20,
  amount : Uint128
  )
end
